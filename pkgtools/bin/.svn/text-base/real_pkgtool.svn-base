###############################################################
###############################################################

#     #                                                   ###
#  #  #    ##    #####   #    #     #    #    #   ####    ###
#  #  #   #  #   #    #  ##   #     #    ##   #  #    #   ###
#  #  #  #    #  #    #  # #  #     #    # #  #  #         #
#  #  #  ######  #####   #  # #     #    #  # #  #  ###
#  #  #  #    #  #   #   #   ##     #    #   ##  #    #   ###
 ## ##   #    #  #    #  #    #     #    #    #   ####    ###

###############################################################
#
# This file should only be updated by the USM team.
# http://wiki.us.nortel.com/twiki/bin/view/Siren/WhoIsUSM
#
# Modifications to this file affect EVERYBODY!
#
###############################################################

############################################################################
# pkgtool
#   - a better packaging tool (no module ties, easy to use)
#   - parses data fields from a filelist.pkg and definition.pkg
#     file and turns them into a properly formatted spec
#   - It then uses rpmbuild to package as an rpm
#
# Written by: Andrew Ross April 14, 2005
#
# Updated by:
#
###############################################################################
#
# Copyright (c) 2010 GENBAND. All rights reserved.
#
# Software owned by or under license with Nortel Networks included in this
# Release is Copyright (c) 2005 Nortel Networks or its licensors.
# Use of this software and its contents is subject to the terms and conditions
# of the applicable end user or software license agreement, right to use notice,
# and all relevant copyright protections.
#
###############################################################################

# Picky is always better therefor...
# NOTE: temporarily turned off so we can include the path macros
use strict;

# Use this module to keep track of which directory we're in
use Cwd;

# Use this module for copying files
use File::Copy;

# Use this module for creating and removing directories
use File::Path;

# Use this module for parsing filenames and paths
use File::Basename;

#######################################################################
# Globals
#######################################################################
use vars (

    # Variables to store the cmdline arguments
    '$opt_a',
    '$opt_b',
    '$opt_d',
    '$opt_D',
    '$opt_e',
    '$opt_f',
    '$opt_g',
    '$opt_h',
    '$opt_i',
    '$opt_l',
    '$opt_m',
    '$opt_o',
    '$opt_p',
    '$opt_r',
    '$opt_s',
    '$opt_t',
    '$opt_T',
    '$opt_u',
    '$opt_v',
    '$opt_w',
    '$opt_x',
    '$opt_y',
    '$opt_z',

    # The following hash variables are for admindata
    '%DefinitionTagCounterHash',  # Used to ensure tags are specified
                                  # no more than once
    '%DefinitionTagHash',         # Stores the data from the definition.pkg,
                                  # after any macros have been evaluated.
    '%OrigDefinitionTagHash',     # Stores the unaltered definition data.

    '@SingleLineTags',            # List of tags that can only be single line.
    '@MultipleLineTags',          # List of tags that can have multiple lines.

    '$Architecture',              # The architecture being built.
    '$TargetArchitecture',        # The installation architecture.
    '$CopyrightTag',              # Copyright directive for specfile

    # Search directories
    '$BinDirectory',
    '$LibDirectory',
    '$AvoidanceDirectory',

    # Bintap variables
    '$BinTapFileMap', 
    '$DontCreateMapFile', 

    # Directories where definition.pkg and filelist.pkg files can be found.
    '$PackagingDirectory',
    '$FilelistDirectory',

    '$OutputDirectory',           # Directory for the pkgtool results

    '$RPMRCfile',                 # Path to rpmrc

    '$HelpOptionSet',             # Indicates -h
    '$Wrapit',                    # Indicates whether pkgtool should call wrapit

    '$BuildrootDirectory',        # Directory used for setting up pkg contents
    '@BuildrootDirectories',      # List of dirs required for pkg

    '$Version',                   # Package version
    '$Release',                   # Package release version

    '$Filelistname',              # Constant, filelist.pkg
    '$DefinitionName',            # Constant, defintion.pkg

    '$Errors',                    # Variable for adding fatal error text
    '$Warnings',                  # Variable for non-fatal warnings

    '$RPMMacrosFile',             # rpmmacros file used by rpmbuild

    '$SpecFile',                  # spec file, used by rpmbuild

    '$CurrentDirectory',          # The current working directory

    '$FileAttributeData',         # Used to build up attr data, written to spec
    '@CopyFiles',                 # List of files to add to the package

    '$RPMRCFile',                 # rpmrc file, used by rpmbuild

    '$TemporaryDirectory',        # Temporary working directory

    '$rpmrc_default',             # Default filename
    '$rpmmacros_default',         # Default filename

    '%ScriptData',                # Hash for scriptlet contents (eg. preinstall)
    '$scripts_default',           # Default name for custom scriptlet directory.
    '@LinkData',                  # Links to add to pkg
    '$PathMacrosFile',            # The path_macros file

    '%PathMacros',                # Available macros, dynamically loaded.
    '%InstallMacros',             # Subset of macros used for install paths.
    '%DirMacros',                 # Subset of macros used only for dir creation paths.
    '%SwamiMacros',               # Subset of macros for swami registrations
    '%runtimeTranslations',       # Mapping of install paths to runtime paths.

    '$ShowMacros',                # Command-line option that displays macros.
    '$HTMLOutput',                # Like ShowMacros, but in HTML format.
    '$swamiOutput',               # Like ShowMacros, but in swami format.

    '$WrapitFromDir',             # If running wrapit automatically, do it here.
    '$WrapitTool',                # Location of wrapit.

    '$swamiRegister',             # Path to swami tool, on Data Manager
    '$checkSwamiRegRC',           # Text for swami registration error checking.
    '$checkSwamiDeregRC',         # Text for swami deregistration error checking.

    '%FileTypeHash',              # Maps swami info types to pkging types
    '%ValidFileTypes',            # List of pkging types
    '%ObsoleteLetterTypes',       # Legacy, list of single-letter pkging types

    '$VSE_RELEASE',               # VSE Platform Release ID (not used for NCGL)
    '$APP_RELEASE',               # Application Release ID (not used for platform)
    '$PRODUCTID',                 # Product ID
    '$PROD_RELEASE',              # Product Release

    '$DRU',                       # Command-line option, to write DRU in admindata

    '$rpmbuild',                  # Path to rpmbuild
    '$rpm2cpio',                  # Path to rpm2cpio
    '$RPMBUILD_VERSION',          # Version of rpmbuild to use

    '$cppat_object_id',           # Path to cppat_object_id

    '$pkgtoolVersion', 
    '$PKGToolsConfigDir',

    # Configuration attributes from packageMapping.list for this package.
    '$PkgTarget',
    '$PkgTargetName',
    '$PkgRole',
    '$PkgPec',
    '%PkgRolesPecs',
    '$PkgLayer',

    '$FinalPkgName',              # Output package name

    # Package handler callback functions, defined in config/pkgtoolHandlers
    '%TypeHelp',
    '%SyntaxParser',
    '%TypeHandler',

    '%pkgmap',                    # Hash to store parsed packageMapping.list
    '$pkgName',                   # Base name of the package being built
    '$pkgType',                   # Type of the package being built

    '$PatchList',                 # Unused, but a cmdline argument
    '$PatchType',                 # Unused, but a cmdline argument

    '$TRUE',
    '$FALSE',

    # Hash for tracking source of packaged files, for generating dependency map
    '%PackagedFiles'
);


init_pkgtool_cfg_dir();
require "$PKGToolsConfigDir/pkgutils.pm";

# pkgtoolVersion must be aligned with the other pkgtools
$pkgtoolVersion = "8.0.3";

#######################################################################
#
# showHelp:
#
#    Display the help message
#
sub showHelp
{
    print STDERR <<OUT;

pkgtool (version $pkgtoolVersion)

Description:
~~~~~~~~~~~~

  pkgtool provides an easy interface for creating RPM packages
    - validates data is proper
    - automatically builds RPM packages
    - wraps with the standard Nortel XML meta data
    - adds a digital signature to the package

Usage:
~~~~~~

  pkgtool <options> <parameters>

  Options:
  ~~~~~~~~
    -h 			print this help text
    -g 			display supported path macros
    -y 			this package is a patch
			(if not set, the last # in version will be checked, 0 for install pkg, non 0 for patch)	
    -m 			turn this package into a parcel by meta data wrapping it

  Basic Options:
  ~~~~~~~~~~~~~~
    -a <architecture> 	the architecture string e.g. i686, ppc, etc.
    -r <release> 	the release number
    -o <output directory> where to place the parcel when completed
    -b <bin directory> 	the place to look for executables
    -s <lib directory> 	the place to look for libraries
    -v <version>	the version for the package
    -p <pkg data dir>	the directory to look for the definition.pkg file
    -f <filelist dir>	the directory to look for the filelist.pkg file (recursively)
    -t <target>	the architecture the package will install on

  Additional Options:
  ~~~~~~~~~~~~~~~~~~~
    -l <avoidance directory> build avoidance directory for files by loadbuild
    -w <macros file> file containing macros to be used
    -t <buildroot directory> the temp directory to assemble the parcel in
    -x <patch list file> a file containing the subset list of files to include in the patch
    -u <html output> file to write html output listing macros
    -z <swami output> file to write swami output listing macros

OUT
    exit 1;
}


sub validateEnvironment()
{
    my $rc = 0;

$PRODUCTID = $ENV{'PRODUCTID'} ne ""
                ? $ENV{'PRODUCTID'}
                : $ENV{'ntmkbw_PRODUCTID'};

    if ($PRODUCTID eq "ha")
    {
        # The other vars aren't required
        return $rc;
    }
    elsif ($PRODUCTID eq "")
    {
        warn "Error: ntmkbw_PRODUCTID must be defined\n";
        $rc = 1;
    }

    # Mandatory for all other layers, including VSE

    $VSE_RELEASE = defined $ENV{VSE_RELEASE} ? $ENV{VSE_RELEASE}
                                             : $ENV{ntmkbw_VSE_RELEASE};

    if ($VSE_RELEASE eq "")
    {
        warn "Error: ntmkbw_VSE_RELEASE must be defined\n";
        $rc = 1;
    }
    # Validate VSE_RELEASE format
    elsif (!($VSE_RELEASE =~ /^\d+\.\d+\.\d+$/))
    {
        warn "Error: VSE_RELEASE ($VSE_RELEASE) has an invalid format.\n";
        $rc = 1;
    }

    $PROD_RELEASE = defined $ENV{PROD_RELEASE} ? $ENV{PROD_RELEASE}
                                               : $ENV{ntmkbw_PROD_RELEASE};

    if ($PROD_RELEASE eq "")
    {
        warn "Error: ntmkbw_PROD_RELEASE must be defined\n";
        $rc = 1;
    }

    if (!defined $ENV{USE_PKGMAPFILE})
    {
        warn "Error: USE_PKGMAPFILE must be defined\n";
        $rc = 1;
    }

    if (!defined $ENV{USE_NCLMAPFILE})
    {
        warn "Error: USE_NCLMAPFILE must be defined\n";
        $rc = 1;
    }

    if ($PRODUCTID eq "Siren")
    {
        # We're done
        return $rc;
    }

    # Mandatory for apps
    $APP_RELEASE = defined $ENV{APP_RELEASE} ? $ENV{APP_RELEASE}
                                             : $ENV{ntmkbw_APP_RELEASE};

    if ($APP_RELEASE eq "")
    {
        warn "Error: ntmkbw_APP_RELEASE must be defined\n";
        $rc = 1;
    }

    if (!defined $ENV{USE_APPNAMES})
    {
        warn "Error: USE_APPNAMES must be defined\n";
        $rc = 1;
    }

    return $rc;
}

#######################################################################
# Constants
#######################################################################

if (validateEnvironment() != 0)
{
    exit 1;
}

$CurrentDirectory=getcwd();

$Filelistname      = "filelist.pkg";
$DefinitionName    = "definition.pkg";
$rpmrc_default     = "rpmrc";
$rpmmacros_default = "rpmmacros";

# Default name for the scripts directory under the packaging directory
$scripts_default   = "scripts";

$FALSE = 0;
$TRUE  = 1;

# Get options
use Getopt::Std;
getopts("a:b:d:D:f:l:o:v:hd:r:t:p:s:x:w:mgu:y:z:T:");
  $Architecture=$opt_a;
  $BinDirectory=$opt_b;
  $BuildrootDirectory=$opt_d;
  $DRU=$opt_D;
  $FilelistDirectory=$opt_f;
  $ShowMacros=$opt_g;
  $HelpOptionSet=$opt_h;
  $Wrapit=$opt_m;
  $AvoidanceDirectory=$opt_l;
  $OutputDirectory=$opt_o;
  $PackagingDirectory=$opt_p;
  $Release=$opt_r;
  $LibDirectory=$opt_s;
  $TargetArchitecture=$opt_t;
  $PatchType=$opt_y;
  $Version=$opt_v;
  $PathMacrosFile=$opt_w;
  $PatchList=$opt_x;
  $HTMLOutput=$opt_u;
  $swamiOutput=$opt_z;

if (!$opt_T or $opt_T eq "fam")
{
    $PkgTarget     = "*";
    $PkgTargetName = "fam";
}
else
{
    $PkgTarget     = $opt_T;
    $PkgTargetName = $opt_T;
}

#######################################################################
# System commands
#######################################################################
$swamiRegister = "/usr/local/bin/swami";

# Where do we get RPM? For licensing, we'll need to have an alternative
# access method. For now, if ivt doesn't exist, we'll use the host tools.
if (-f "/opt/tools/bin/ivt")
{
    # Use version 4.2.1 to build RPMs. This is the version RPM
    # used by the VSE 1.1 release. It ensures that the VSE 1.1
    # software can install RPMs, even when they are built for
    # a later VSE release that uses a newer version of RPM. The
    # later VSE releases should be able to install RPMs using
    # this older version of RPM.
    $RPMBUILD_VERSION = "4.2.1_wrs";
    chomp($rpmbuild = `/opt/tools/bin/ivt rpm $RPMBUILD_VERSION which rpmbuild`);
    chomp($rpm2cpio = `/opt/tools/bin/ivt rpm $RPMBUILD_VERSION which rpm2cpio`);
    $CopyrightTag = "Copyright:";
}
else
{
    chomp($rpmbuild = `which rpmbuild`);
    chomp($rpm2cpio = `which rpm2cpio`);
    $CopyrightTag = "License:";
}

$checkSwamiRegRC =<<EOF;

returnCode=\$?
if [ \${returnCode} -ne 1 ]
then
  echo "Fatal: Command failed with return status: \${returnCode}"
  exit 1
fi
EOF

$checkSwamiDeregRC =<<EOF;

returnCode=\$?
if [ \${returnCode} -ne 1 ]
then
  echo "Warning: Command failed with return status: \${returnCode}"
fi
EOF

# Create a placeholder for the admindata, errors, and warnings
$Errors="";
$Warnings="";

#######################################################################
# Functions
#######################################################################

sub init_pkgtool_cfg_dir()
{
    if (!$PKGToolsConfigDir)
    {
        # Use the rpmrc file to tell if the config directory exists
        # prefer the vob path (as it managed), then the wharehouse,
        # then the local path
        my $entryinvob="$ENV{USE_SRC_ROOT}/vob/siren/tools/pkgtools/config/rpmrc";
        my $localentry="./pkgtools/config/rpmrc";

        my $PKGTOOLSPATH=$ENV{'pkgtoolPATH'};

        if (!$PKGTOOLSPATH)
        {
            $PKGTOOLSPATH="./pkgtools";
        }

        my $entryinwharehouse=$PKGTOOLSPATH . "/config/rpmrc";

        if (-f $entryinvob)
        {
            $PKGToolsConfigDir="$ENV{USE_SRC_ROOT}/vob/siren/tools/pkgtools/config";
            $WrapitTool="$ENV{USE_SRC_ROOT}/vob/siren/tools/pkgtools/wrapit";
            $cppat_object_id = "$ENV{USE_SRC_ROOT}/vob/siren/tools/pkgtools/utils/cppat_object_id";
        }
        elsif (-f $entryinwharehouse)
        {
            $PKGToolsConfigDir=$PKGTOOLSPATH . "/config";
            $WrapitTool= $PKGTOOLSPATH . "/bin/wrapit";
            $cppat_object_id = $PKGTOOLSPATH . "/bin/cppat_object_id";
        }
        elsif (-f $localentry)
        {
            $PKGToolsConfigDir=$PKGTOOLSPATH . "/config";
            $WrapitTool= $PKGTOOLSPATH . "/wrapit";
            $cppat_object_id = "";
        }
        else
        {
            $Errors .= "\n\tCouldn't find rpm configuration information for pkgtool.\n";
        }
    }
}


#######################################################################
# set_defaults()
#    Initialize some variables and create some directories.
#######################################################################
sub set_defaults()
{
    my $Now=`date +"%s"`;
    chomp ($Now);

    my $UserName=$ENV{'LOGNAME'};
    chomp ($UserName);

    my $HostName=$ENV{'HOSTNAME'};
    chomp ($HostName);

    if ($Version)
    {
        $PathMacros{"current_version"}=$Version;
    }

    print "\nSetting defaults...\n";

    if (!$TemporaryDirectory)
    {
        my $TempDirCounter=0;
        $TemporaryDirectory="./pkgtool_temp_" . $UserName . $$ . $Now . $TempDirCounter . $HostName;
        while (-d $TemporaryDirectory)
        {
            $TempDirCounter++;
            $TemporaryDirectory="./pkgtool_temp_" . $UserName . $$ . $Now . $TempDirCounter . $HostName;
        }
    }

    if (!$BuildrootDirectory)
    {
        $BuildrootDirectory="$CurrentDirectory/buildroot_" . $UserName . $$ . $Now . $HostName;
    }

    if (!$PathMacrosFile)
    {
        $PathMacrosFile=$PKGToolsConfigDir . "/path_macros";
    }

    if (!$Architecture)
    {
        $Architecture="intel_c";
    }

    if (!$OutputDirectory)
    {
        $OutputDirectory="$CurrentDirectory";
    }

    if (!$FilelistDirectory)
    {
        $FilelistDirectory="$CurrentDirectory";
    }

    if (!$Release)
    {
        $Release="1";
    }

    if (!$Version)
    {
        $Version="1.0.0";
    }

    if (!$PackagingDirectory)
    {
        $PackagingDirectory="$CurrentDirectory";
    }

    # DontCreateMapFile is used to skip mapfile creation for family/targets
    # that don't exist in the packageMapping.list (or for NCGLHA layer).
    # Likewise, if bintap is not enabled for the build, don't create the
    # mapfile.
    $DontCreateMapFile = ($ENV{BINTAP_BUILD_ENABLED} ne "1");

    print "  Date:           " . `date`;
    # print "  Host:           $HostName\n";
    print "  User:           $UserName\n";
    print "  Version:        $Version\n";
    print "  Temp dir:       $TemporaryDirectory\n";
    print "  Build root dir: $BuildrootDirectory\n";
    print "  Config dir:     $PKGToolsConfigDir\n";
    print "  Wrapit tool     $WrapitTool\n";
    print "  Macros dir:     $PathMacrosFile\n";
    print "  Architecture:   $Architecture\n";
    print "  Output dir:     $OutputDirectory\n";
    print "  Filelist dir:   $FilelistDirectory\n";
    print "  Packaging dir:  $PackagingDirectory\n";
    print "  Strip objects:  " .
        ((($ENV{OBJCOPY} ne "") && (uc($ENV{USE_PKGTOOL_STRIP}) eq "Y")) ? "Y" : "N") . "\n";
    print "  Create mapfile: " . ($DontCreateMapFile ? "N" : "Y") . "\n";

    if (defined $ENV{'USE_BINTAP_NAME'})
    {
        print "  Bintap Ext:     $ENV{'USE_BINTAP_NAME'}\n";
    }
}


#############################################################
# dereference_macros()
# - accepts a string and substitutes macros for their values
# - returns the converted string
#############################################################
sub dereference_macros
{
    my $LineInput=$_[0];
    my $Before=$LineInput;

    # If the line has any macros, substitute the path for the macro
    if ($LineInput =~ /\$/)
    {
        # First, substitute current_arch for the current architecture,
        # if present, as the path macros use the architecture name.
        $LineInput =~ s/\${current_arch/\${$Architecture/g;
        $LineInput =~ s/\${current_target/\${$PkgTargetName/g;

        # We check for all macros.. a little slower but very thorough
        foreach my $Macro (keys %PathMacros)
        {
            $LineInput =~ s/\${$Macro}/$PathMacros{$Macro}/g;
        }
    }

    if ($LineInput ne $Before)
    {
        print "Successful macro substitution:\n";
        print "Before: $Before\n";
        print "After: $LineInput\n";
    }

    return ($LineInput);
}


#############################################################
# dereference_definition_values
# - evalutes any macros in the definition data
#############################################################
sub dereference_definition_values
{
    foreach my $Key (keys %OrigDefinitionTagHash)
    {
        $DefinitionTagHash{$Key} = dereference_macros($OrigDefinitionTagHash{$Key});
        $DefinitionTagHash{$Key} =~ s/[\$\{\}]//g; # Discard these characters
    }
}


#############################################################
# parse_definition()
# - read definition file data into a hash
#############################################################
sub parse_definition
{
    # Set some defaults for those who aren't using the key registration system
    $OrigDefinitionTagHash{"key"}="no_key";
    $OrigDefinitionTagHash{"key_id"}="0";
    $OrigDefinitionTagHash{"key_description"}="no_key_description";

    if (defined $APP_RELEASE)
    {
        # For applications, the default key_version is their release id,
        # for convenience.
        $OrigDefinitionTagHash{"key_version"}="$APP_RELEASE";
    }
    else
    {
        $OrigDefinitionTagHash{"key_version"}="no_key_version";
    }

    my $DefinitionFile="$PackagingDirectory/$DefinitionName";
    print "\nSearching for definition file: $DefinitionFile  ";

    # If we're not simply outputting swami or HTML data,
    # we absolutely must have a definition file to build a package
    if($swamiOutput or $HTMLOutput or $ShowMacros)
    {
        print "[N/A]\n";
        return $TRUE;
    }
    elsif (!-f $DefinitionFile)
    {
        print "[FAILED]\n";
        $Errors .= "\n\tDefinition file not found: $DefinitionFile\n";
        return $FALSE;
    }
    else
    {
        # TODO, replace this later with an open command
        my $DefinitionData=`cat $DefinitionFile | grep -v '#'`;
        print "[OK]\n";

        # The tags to look for in the definition file

        # These tags CANNOT have a newline in them
        @SingleLineTags = ('static_name',
                           'pkg_name',
                           'pkg_summary',
                           'software_id',
                           'product_component',
                           'product_component_version',
                           'version',
                           'auto_apply',
                           'activation_required',
                           'reboot_required',
                           'updated',
                           'created',
                           'title',
                           'payload_filename',
                           'payload_checksum',
                           'payload_size',
                           'last_vscan_date',
                           'vscan_definitions',
                           'status',
                           'category',
                           'vo_site',
                           'vo_prime',
                           'hardware_platform',
                           'operating_system',
                           'patch_updates',
                           'type',
                           'removal_options',
                           'class',
                           'web_post',
                           'encryption',
                           'portal_id',
                           'apply_handling',
                           'creation_date',
                           'key',
                           'key_version',
                           'key_id',
                           'baseline_release');

        my $ArchRequires = "requires_$Architecture";

        # These tags CAN have a newline in them
        @MultipleLineTags = ('pkg_description',
                             'software_package',
                             'install_instructions',
                             'test_instructions',
                             'warning',
                             'requires',
                             'provides',
                             'supercedes',
                             'incompatible_with',
                             'cr',
                             'cr_title',
                             'signature_certificate',
                             'design_updates',
                             'patch_updates',
                             $ArchRequires);

        # Load the single line tags
        foreach my $Tag (@SingleLineTags)
        {
            my $StartTag = quotemeta("<$Tag>");
            my $EndTag = quotemeta("</$Tag>");

            if($DefinitionData =~ m/$StartTag(.*?)$EndTag/)
            {
                # $1 is the output from the pattern match above.
                $OrigDefinitionTagHash{$Tag} = $1;
                $DefinitionTagCounterHash{$Tag}++;

                # If we find a tag more than once, it's an error
                if ($DefinitionTagCounterHash{$Tag} > 1)
                {
                    $Errors .= "\n\tFor $DefinitionFile:";
                    $Errors .= "\n\tTag: $Tag populated more than once. This is time " . $DefinitionTagCounterHash{$Tag} . "\n";
                }
            }
        }

        # Load the multiple line tags
        foreach my $Tag (@MultipleLineTags)
        {
            my $StartTag = quotemeta("<$Tag>");
            my $EndTag = quotemeta("</$Tag>");

            if($DefinitionData =~ m/$StartTag(.*?)$EndTag/s)
            {
                # $1 is the output from the pattern match above.
                $OrigDefinitionTagHash{$Tag} = $1;
                $DefinitionTagCounterHash{$Tag}++;

                # If we find a tag more than once, it's an error
                if ($DefinitionTagCounterHash{$Tag} > 1)
                {
                    $Errors .= "\n\tFor $DefinitionFile:";
                    $Errors .= "\n\tTag: $Tag populated more than once. This is time " . $DefinitionTagCounterHash{$Tag} . "\n";
                }
            }
        }

        # If there were any architecture specific requires, include them in the requires field
        if ($OrigDefinitionTagHash{$ArchRequires})
        {
            $OrigDefinitionTagHash{"requires"} .= $OrigDefinitionTagHash{$ArchRequires};
        }

        if ($DRU)
        {
            # Passed a DRU - store it in the definition hash for later use.
            $OrigDefinitionTagHash{"DRU"}=$DRU;
        }

        print "Loaded definitions.\n";
        return $TRUE;
    }
    return $FALSE;
}


#############################################################
# parse_filelists()
# - search recursively in packaging dir for filelist.pkg files
# - reads the data from filelist files into a hash
#############################################################
sub parse_filelists()
{
  print "\nSearching for filelist file(s): $Filelistname  ";

  # The / is added to $FilelistDirectory to handle symbolic links.
  my @FilelistFiles=`find $FilelistDirectory/ -name "$Filelistname" -print`;

  # If we don't find any return false
  if (scalar @FilelistFiles == 0)
  {
     print "[FAILED]\n";
     $Errors .= "\n\tThere were no $Filelistname files found.\n";
     return $FALSE;
  }

  foreach my $FilelistFile (@FilelistFiles)
  {
     print "[OK]\n";

    my @FileContents="";

    # Read the file
    chomp ($FilelistFile);
    open (FILELIST,"< $FilelistFile");

    while (<FILELIST>)
    {
      s/#.*//; # Ignore comments
      chomp;   # Strip newlines

      # Only if there's something left
      if ($_)
      {
        my %attr = ();

        $attr{key}         = $DefinitionTagHash{"key"};
        $attr{key_id}      = $DefinitionTagHash{"key_id"};
        $attr{key_version} = $DefinitionTagHash{"key_version"};

        my ($type, @fields) = split /\s+/, $_;
        my $line = join " ", @fields;

        # Translate the type field, to remove obsolete types
        translate_file_type(\$type);

        # Replace current_arch references with the actual arch
        $line =~ s/\$\{current_arch/\$\{$Architecture/g;
        $line =~ s/\${current_target/\$\{$PkgTargetName/g;

        # Now we'll call the parser and handler routines
        callSyntaxParser($type, $line, \%attr);
        check_for_errors();

        callTypeHandler($type, \%attr);
        check_for_errors();
      }
    }
  }
  close (FILELIST);
  check_for_errors();

  print "Loaded filelist(s).\n";
  return $TRUE;
}


#############################################################
# valid_model_type()
#############################################################
sub valid_model_type()
{
  my $Type=$_[0];

  # If the type provided is a valid data model type, we return true
  foreach my $FileType (sort keys %FileTypeHash)
  {
    my $ValidType=$FileTypeHash{$FileType};
    if ($Type eq $ValidType)
    {
      return $TRUE;
    }
  }

  return $FALSE;
}


#############################################################
# read_macros()
#############################################################
sub read_macros()
{
    loadEnvironmentMacros();

    if ($PRODUCTID eq "ha")
    {
        loadNcglMacros();
    }
    elsif ($PRODUCTID eq "Siren")
    {
        loadCnpMacros($VSE_RELEASE, $Architecture, $PkgTarget, $PkgRole, $PkgPec, $pkgName);
    }
    else
    {
        for my $appName (split /\s+/, $ENV{'USE_APPNAMES'})
        {
            loadAppMacros($appName, $APP_RELEASE, $Architecture, $PkgTarget, $PkgRole, $PkgPec, $VSE_RELEASE);
        }
    }

    print "Loaded Path Macros.\n";
}


#############################################################
# buildFinalPkgName()
#############################################################
sub buildFinalPkgName()
{
  $FinalPkgName = $pkgmap{$pkgName}{$PkgLayer}{$Architecture}{$PkgTarget}{$PkgRole}{$PkgPec}{'NAME'};

  # For bintap type patches, the parcel name should contain
  # _TAP_$bintapVersion at the end
  # This is used to have unique parcel names
  if (defined $ENV{'USE_BINTAP_NAME'})
  {
    $FinalPkgName .= $ENV{'USE_BINTAP_NAME'};
  }
  printf "Final Package Name: $FinalPkgName\n";
}


#############################################################
# loadHandlers()
#############################################################
sub loadHandlers()
{
    require "$PathMacrosFile";
    require "$PKGToolsConfigDir/pkgtoolHandlers";
}


#############################################################
# getPatchObjectId()
#############################################################
sub getPatchObjectId($$)
{
    my $runtime = shift;
    my $filepath = shift;

    if (! -x $cppat_object_id)
    {
        # object_id generation tool is not in the environment.
        # Return an empty string to be written to the map file.
        return "";
    }

    my $object_id = `$cppat_object_id $runtime $filepath 2>&1`;

    if ($? != 0)
    {
       $Errors .= "\n\tCould not calculate object_id for $filepath\n";
       $Errors .= "\tOutput: $object_id\n";
    }

    chomp $object_id;
    return $object_id;
}

#############################################################
# create_buildroot()
#############################################################
sub create_buildroot
{
  my @bintapMapFileContents = ();

  print "\nCreate BUILDROOT dir:\n  $BuildrootDirectory\n";

  if (-d $BuildrootDirectory)
  {
     rmtree($BuildrootDirectory);
  }

  print "Create paths in BUILDROOT dir: ";
  foreach my $NeededDirectory ($BuildrootDirectory, @BuildrootDirectories)
  {
    if (!-d $NeededDirectory)
    {
      my $tmp = $NeededDirectory;
      $tmp =~ s/$BuildrootDirectory//;
      print "  .$tmp  ";
      if(!mkpath($NeededDirectory))
      {
           print "[FAILED]\n";
           $Errors .= "\n\tCould not create needed dir: $NeededDirectory\n";
      }
      else
      {
           print "[OK]\n";
      }
    }
  }

  print "\nCopy files into BUILDROOT:\n";

  foreach my $FileToCopy (@CopyFiles)
  {
    # $FileToCopy = <$instPath/$file>::<Search|$path>
    my @FileCopyParts=split("::",$FileToCopy);
    my @FileNameParts=split("/",@FileCopyParts[0]);
    my $FileName=pop(@FileNameParts);
    my $ok         = 1;
    my $fileFound  = "";

    # If the file location was not known, search for it
    if (@FileCopyParts[1] eq "Search")
    {
      # Set all three files we might look for
      my $BinFile=$BinDirectory . "/" . $FileName;
      my $LibFile=$LibDirectory . "/" . $FileName;
      my $AvoidanceFile=$AvoidanceDirectory . "/" . $FileName;

      if (-f $BinFile)
      {
           $fileFound  = $BinFile;
      }
      elsif (-f $LibFile)
      {
           $fileFound  = $LibFile;
      }
      elsif (-f $AvoidanceFile)
      {
           $fileFound  = $AvoidanceFile;
      }
      else
      {
           $ok = 0;
           print "-> Failed.\n";
           $Errors .= "\tError: Could not find: $FileName\n";
      }

      $PackagedFiles{$fileFound}++;
    }
    # Tarfile handling
    elsif (@FileCopyParts[1] eq "TAR")
    {
        my $tarfile = $FileCopyParts[0];
        my $rootdir = $FileCopyParts[2];

        $ok = 0;  # Avoid copying file to BINTAPMAPFILE below.

        # Add extra tar options, if needed, based on file type.
        my $extractOptions;
        my $fileInfo = `file $tarfile`;
        if ($fileInfo =~ m/gzip compressed/)
        {
            $extractOptions = "xzf";
        }
        elsif ($fileInfo =~ m/bzip2 compressed/)
        {
            $extractOptions = "xjf";
        }
        elsif ($fileInfo =~ m/tar archive/)
        {
            $extractOptions = "xf";
        }
        else
        {
            $Errors .= "\nCould not determine type of tar file for $tarfile\n";
            next;
        }

        my $extractDir = $BuildrootDirectory . $rootdir;

        print "\nExtracting contents of $tarfile...\n";
        `tar $extractOptions $tarfile -C $extractDir`;
        if ($? != 0)
        {
            $Errors .= "\n Failed to extract contents of $tarfile\n";
        }

        $PackagedFiles{$tarfile}++;
     }
    elsif (@FileCopyParts[1] eq "RPM")
    {
        my $rpmfile = $FileCopyParts[0];
        my $rootdir = $FileCopyParts[2];

        $ok = 0;  # Avoid copying file to BINTAPMAPFILE below.

        my $extractDir = $BuildrootDirectory . $rootdir;

        print "\nExtracting contents of $rpmfile...\n";
        system("cd $extractDir && ${rpm2cpio} $rpmfile | cpio -id");
        if ($? != 0)
        {
            $Errors .= "\n Failed to extract contents of $rpmfile\n";
        }

        $PackagedFiles{$rpmfile}++;
     }
     else
     {
        # Otherwise we knew where it was supposed to be - just copy it
        $fileFound  = $FileCopyParts[1];
        $PackagedFiles{$fileFound}++;
     }

     if ($ok)
     {
        my $CopiedFile = $BuildrootDirectory . $FileCopyParts[0];
        print "  Copy: $fileFound\n    To: \$BUILDROOT${FileCopyParts[0]}  ";
        if (copy($fileFound, $CopiedFile))
        {
           print "[OK]";

           if (($ENV{OBJCOPY} ne "") && (uc($ENV{USE_PKGTOOL_STRIP}) eq "Y"))
           {
               # If objcopy is unable to strip the file, eg. it's a text file
               # or some other non-strippable file, it will return a non-zero
               # value and leave the file untouched.
               system("$ENV{OBJCOPY} --strip-debug --remove-section .symcheck $CopiedFile >/dev/null 2>&1");
               if ($? == 0)
               {
                   print " (stripped)\n";
               }
           }
           print "\n";

           #pkgname::family::build_output_location::install_location::runtime_location
           my $uniqKey = $Architecture . "." . $PkgTargetName . "." . $DefinitionTagHash{"pkg_name"};
           if (!$DontCreateMapFile)
           {
              my $RunTimeMapField = translateInstallToRuntime($FileCopyParts[0]);
              my $object_id = getPatchObjectId($RunTimeMapField, $CopiedFile);

              my $map_line = $DefinitionTagHash{"pkg_name"} . "::" .
                             $Architecture . "." . $PkgTargetName .  "::" .
                             $fileFound . "::" .
                             $uniqKey . "::" .
                             $RunTimeMapField . "::" .
                             $object_id . "\n";
              push @bintapMapFileContents, $map_line;
           }
        }
        else
        {
           print "[FAILED]\n";
           $Errors .= "\n\tError copying: $fileFound to $CopiedFile\n";
        }
     }
  }  # foreach $Filetocopy

  if (scalar @bintapMapFileContents > 0)
  {  
      $BinTapFileMap="$OutputDirectory/$FinalPkgName" . ".map";

      # Open filemap for writing 
      open (BINTAPFILEMAP, "> $BinTapFileMap");
      for my $line (@bintapMapFileContents)
      {
          print BINTAPFILEMAP "$line";
      }

      close(BINTAPFILEMAP);
  }

  foreach my $LinkToSetup (@LinkData)
  {
    my @LinkComponents = split("::", $LinkToSetup);

    my $LinkCommand = @LinkComponents[0];
    my $TargetLink = @LinkComponents[1];
    my $LinkItself = @LinkComponents[2];

    my @LinkPathParts = fileparse($LinkItself, qr/\.[^.]*/);
    my $DirectoryHoldingLink = @LinkPathParts[1];
    my $DirectoryToChangeTo = $BuildrootDirectory . $DirectoryHoldingLink;

    my @LinkPartsBySlash = split("/",$LinkItself);
    my $LinkName = pop(@LinkPartsBySlash);

    my $CommandToRun = $LinkCommand  . $TargetLink . " " . $LinkName;
    system("cd $DirectoryToChangeTo; $CommandToRun");
  }
}


#############################################################
# setup_rpmmacros()
# - set up a rpmmacros that control the output
#   controls the output directory, the configuration directory
#   and other stuff... read the code
#############################################################
sub setup_rpmmacros
{
  print "\nCreating rpm macros file\n";
  $RPMMacrosFile =  $TemporaryDirectory . "/" . $rpmmacros_default;

  if (-d $TemporaryDirectory)
  {
    rmtree($TemporaryDirectory);
  }
  else
  {
    if(!mkpath($TemporaryDirectory))
    {
        $Errors .= "\n\tFailed to create temp dir: $TemporaryDirectory\n";
      return $FALSE;
    }
  }

  if (-f $RPMMacrosFile)
  {
    system ("rm $RPMMacrosFile");
    if (!$? == 0)
    {
        $Errors .= "\n\tFailed to delete existing rpmmacros file: $RPMMacrosFile\n";
      return $FALSE;
    }
  }

  # Here's where we write the stuff we need in the macros file
  open (MACROS,"> $RPMMacrosFile");
  print MACROS "%_config_dir " . $PKGToolsConfigDir . "\n";
  print MACROS "%_topdir " . $BuildrootDirectory . "\n";
  print MACROS "%_builddir %{_topdir}\n";

  if ($Wrapit)
  {
    my $Now=`date +"%s"`;
    chomp ($Now);
    $WrapitFromDir="./wrapit_input_" . $Now . $$;
    print MACROS "%_rpmdir " . $WrapitFromDir . "\n";
  }
  else
  {
    print MACROS "%_rpmdir " . $OutputDirectory . "\n";
  }

  # The naming convention is defined here
  print MACROS "%_rpmfilename %%{NAME}-%%{VERSION}-%%{RELEASE}.%%{ARCH}.rpm\n";
  close (MACROS);

  return $TRUE;
}


#############################################################
# setup_rpmrc()
#############################################################
sub setup_rpmrc
{
  print "\nCreating rpmrc file\n";

  my $OriginalRPMRCFile=$PKGToolsConfigDir . "/$rpmrc_default";
  $RPMRCFile=$TemporaryDirectory . "/$rpmrc_default";

  my $RPMRCData=`cat $OriginalRPMRCFile`;

  for ($RPMRCData)
  {
    s/REPLACE_WITH_MACROFILE/$RPMMacrosFile/g;
  }

  open (RPMRC,"> $RPMRCFile");
  print RPMRC $RPMRCData;
  close (RPMRC);

  #  $Errors .= "\n\tError: Could not copy $OriginalRPMRCFile to $RPMRCFile\n";
}


#############################################################
# write_specfile()
#############################################################
sub write_specfile
{
  print "\nCreating specfile\n";
  $SpecFile=$TemporaryDirectory . "/" . $FinalPkgName . "-" . $Release . "." . $Version . ".spec";
  open (SPECFILE,"> $SpecFile");
  print SPECFILE "Summary: " . $DefinitionTagHash{"pkg_summary"} . "\n";

  # If the user has asked for a static name (don't add architecture)
  # use it
  if ($DefinitionTagHash{"static_name"})
  {
    print SPECFILE "Name: " . $DefinitionTagHash{"static_name"} . "\n";
  }
  else
  {
    print SPECFILE "Name: " . $FinalPkgName . "\n";
  }

  print SPECFILE "Version: " . $Version . "\n";
  print SPECFILE "Release: " . $Release . "\n";
  print SPECFILE "Vendor: Nortel\n";
  print SPECFILE "Group: Nortel/Base\n";

  my $CurrentYear=`date +"%Y"`;
  print SPECFILE "$CopyrightTag: commercial - GENBAND $CurrentYear\n";

  # TODO: replace this with an ldap lookup of the current user
  #       we'll have logic to map sirenbld, sopcdelv & friends
  #       to a fixed support email address
  #       NOTE: We don't want designer-private builds going to the field
  my $USER=$ENV{'LOGNAME'};

  # Prefer the user's username for the packager field if set
  # Otherwise set it as pkgtool
  if ($USER)
  {
    print SPECFILE "Packager: $USER\@nortel.com\n";
  }
  else
  {
    print SPECFILE "Packager: pkgtool\@nortel.com\n";
  }

  print SPECFILE "Buildroot: $BuildrootDirectory\n";

  my @Provides=split("\n",$DefinitionTagHash{"provides"});
  foreach my $Provide (@Provides)
  {
    # Strip the whitespace
    for ($Provide)
    {
      s/ //g;
      s/\t//g;
    }

    # Only if something is left, add it to the spec
    if ($Provide)
    {
      print SPECFILE "Provides: $Provide\n";
    }
  }

  my @Prerequisites=split("\n",$DefinitionTagHash{"requires"});
  foreach my $Prereq (@Prerequisites)
  {
    # Strip the whitespace
    $Prereq =~ s/\s+//g;

    # Only if something is left, add it to the spec
    if ($Prereq)
    {
        my $req = translateRequires($Prereq,
                                    \%pkgmap,
                                    $Architecture,
                                    $PkgTarget,
                                    $PkgRole,
                                    $PkgPec);

        print SPECFILE "Requires: $req\n";
    }
  }

  print SPECFILE "%description\n" . $DefinitionTagHash{"pkg_description"} . "\n";

  # Automatically insert the version numbers so people can retrieve
  my $VersionCopy=$Version;
  for ($VersionCopy)
  {
    s/\./::/g;
  }
  my @VersionParts=split("::",$VersionCopy);

  my $LastNumber=pop(@VersionParts);
  my $FirstNumber=@VersionParts[0];


  # Preinstall
  print SPECFILE "%pre\n";
  print SPECFILE "USM_SCENARIO=\$1\n";
  print SPECFILE "echo \"USM_SCENARIO is: \${USM_SCENARIO}\"\n";
  print SPECFILE "# Automatic version insertion by pkgtool\n";
  print SPECFILE "USM_VERSION=" . $Version . "\n";
  print SPECFILE "USM_PATCH_VERSION=" . $LastNumber . "\n";
  print SPECFILE "USM_RELEASE_VERSION=" . $FirstNumber . "\n";
  print SPECFILE "VSE_RELEASE=$VSE_RELEASE\n" if (defined $VSE_RELEASE);
  print SPECFILE "APP_RELEASE=$APP_RELEASE\n" if (defined $APP_RELEASE);

  print SPECFILE "\n#Custom user provided scripts inserted by pkgtool\n";
  print SPECFILE $ScriptData{"preinstall"} . "\n\n\n";
  print SPECFILE "\nexit 0\n";

  # Postinstall
  print SPECFILE "%post\n";
  print SPECFILE "USM_SCENARIO=\$1\n";
  print SPECFILE "echo \"USM_SCENARIO is: \${USM_SCENARIO}\"\n";
  print SPECFILE "# Automatic version insertion by pkgtool\n";
  print SPECFILE "USM_VERSION=" . $Version . "\n";
  print SPECFILE "USM_PATCH_VERSION=" . $LastNumber . "\n";
  print SPECFILE "USM_RELEASE_VERSION=" . $FirstNumber . "\n";
  print SPECFILE "VSE_RELEASE=$VSE_RELEASE\n" if (defined $VSE_RELEASE);
  print SPECFILE "APP_RELEASE=$APP_RELEASE\n" if (defined $APP_RELEASE);
  print SPECFILE "USMBASEDIR=/usm_protected/cnp/$Architecture/$VSE_RELEASE #Available only in usmsetup package\n" if ($pkgName eq "usmsetup");

  print SPECFILE "\n# Automatic swami registration inserted by pkgtool\n";
  if (defined $ScriptData{"swami_register"})
  {
    if ($PRODUCTID eq "ha")
    {
        # This package could be installed on a non-VSE system
        print SPECFILE "if [ -x \"/usr/local/bin/swami\" ] ; then\n\n";
    }

  print SPECFILE "if [ \"\${USM_SCENARIO}\" = \"1\" -o \"\${USM_SCENARIO}\" = \"2\" ]\n";
  print SPECFILE "then\n";
  print SPECFILE "echo \"Adding swami registrations.\"\n";
  print SPECFILE $ScriptData{"swami_register"};
  print SPECFILE "fi\n\n";

    if ($PRODUCTID eq "ha")
    {
        print SPECFILE "fi # End swami check\n\n";
    }
  }
  else
  {
    print SPECFILE "# No registrations\n\n";
  }

  print SPECFILE "#Custom user provided scripts inserted by pkgtool\n";
  print SPECFILE $ScriptData{"postinstall"} . "\n\n\n";
  print SPECFILE "\nexit 0\n";

  # Preremove
  print SPECFILE "%preun\n";
  print SPECFILE "USM_SCENARIO=\$1\n";
  print SPECFILE "echo \"USM_SCENARIO is: \${USM_SCENARIO}\"\n";
  print SPECFILE "# Automatic version insertion by pkgtool\n";
  print SPECFILE "USM_VERSION=" . $Version . "\n";
  print SPECFILE "USM_PATCH_VERSION=" . $LastNumber . "\n";
  print SPECFILE "USM_RELEASE_VERSION=" . $FirstNumber . "\n";
  print SPECFILE "VSE_RELEASE=$VSE_RELEASE\n" if (defined $VSE_RELEASE);
  print SPECFILE "APP_RELEASE=$APP_RELEASE\n" if (defined $APP_RELEASE);
  print SPECFILE "\n#Custom user provided scripts inserted by pkgtool\n";
  print SPECFILE $ScriptData{"preremove"} . "\n\n\n";
  print SPECFILE "\nexit 0\n";

  # Postremove
  print SPECFILE "%postun\n";
  print SPECFILE "USM_SCENARIO=\$1\n";
  print SPECFILE "echo \"USM_SCENARIO is: \${USM_SCENARIO}\"\n";
  print SPECFILE "# Automatic version insertion by pkgtool\n";
  print SPECFILE "USM_VERSION=" . $Version . "\n";
  print SPECFILE "USM_PATCH_VERSION=" . $LastNumber . "\n";
  print SPECFILE "USM_RELEASE_VERSION=" . $FirstNumber . "\n";
  print SPECFILE "VSE_RELEASE=$VSE_RELEASE\n" if (defined $VSE_RELEASE);
  print SPECFILE "APP_RELEASE=$APP_RELEASE\n" if (defined $APP_RELEASE);

  print SPECFILE "\n# Automatic swami registration inserted by pkgtool\n";
  if (defined $ScriptData{"swami_deregister"})
  {
    if ($PRODUCTID eq "ha")
    {
        # This package could be installed on a non-VSE system
        print SPECFILE "if [ -x \"/usr/local/bin/swami\" ] ; then\n\n";
    }

  print SPECFILE "if [ \"\${USM_SCENARIO}\" = \"0\" ]\n";
  print SPECFILE "then\n";
  print SPECFILE "echo \"Removing swami registrations.\"\n";
  print SPECFILE $ScriptData{"swami_deregister"};
  print SPECFILE "fi\n\n";

    if ($PRODUCTID eq "ha")
    {
        print SPECFILE "fi # End swami check\n\n";
    }
  }
  else
  {
    print SPECFILE "# No registrations\n\n";
  }

  print SPECFILE "#Custom user provided scripts inserted by pkgtool\n";
  print SPECFILE $ScriptData{"postremove"} . "\n\n\n";
  print SPECFILE "\nexit 0\n\n";

  print SPECFILE "%files\n";

  # If we have any script data to deliver, write it now in the buildroot and
  # include it in the spec
  if ($ScriptData{"registrations"})
  {
    my $DynamicScriptFile=$PathMacros{"register_scripts"} . "/" . $FinalPkgName . "_" . $DefinitionTagHash{"key"} . "_" . $DefinitionTagHash{"key_version"} . "." . $Architecture . ".usm_script";

    my $BuildrootScriptFile=$BuildrootDirectory . $DynamicScriptFile;

    my @PathParts = fileparse($BuildrootScriptFile, qr/\.[^.]*/);
    my $DirectoryToCreate = @PathParts[1];

    if(!-d $DirectoryToCreate)
    {
        if(!mkpath($DirectoryToCreate))
        {
          $Errors .= "\n\tCould not create dir: $DirectoryToCreate\n";
        }
    }
    open (DYNAMIC_SCRIPT,"> $BuildrootScriptFile");
    print DYNAMIC_SCRIPT $ScriptData{"registrations"};
    close (DYNAMIC_SCRIPT);

    $FileAttributeData = $FileAttributeData . "\n" . "%attr(755, root, root) " . $DynamicScriptFile;
  }

  # If we have any BACKUP script data to deliver, write it now in the buildroot and
  # include it in the spec
  if ($ScriptData{"backupregistrations"})
  {
    my $DynamicScriptFile=$PathMacros{"backup_scripts"} . "/" . $FinalPkgName . "_" . $DefinitionTagHash{"key"} . "_" . $DefinitionTagHash{"key_version"} . "." .  $Architecture . ".usm_script";

    my $BuildrootScriptFile=$BuildrootDirectory . $DynamicScriptFile;

    my @PathParts = fileparse($BuildrootScriptFile, qr/\.[^.]*/);
    my $DirectoryToCreate = @PathParts[1];

    if(!-d $DirectoryToCreate)
    {
        if(!mkpath($DirectoryToCreate))
        {
           $Errors .= "\n\t: Could not create dir: $DirectoryToCreate\n";
        }
    }
    open (DYNAMIC_SCRIPT,"> $BuildrootScriptFile");
    print DYNAMIC_SCRIPT $ScriptData{"backupregistrations"};
    close (DYNAMIC_SCRIPT);

    $FileAttributeData = $FileAttributeData . "\n" . "%attr(755, root, root) " . $DynamicScriptFile;
  }

  print SPECFILE $FileAttributeData;
  close (SPECFILE);

  return $TRUE;
}


#############################################################
# build_rpm()
#############################################################
sub build_rpm()
{
  print "\nCreating rpm package\n";
  system("${rpmbuild} --rcfile $RPMRCFile -bb $SpecFile");
  if ($? == 0)
  {
      return $TRUE;
  }
  else
  {
      $Errors .= "\n\tCould not create rpm package.\n";
      return $FALSE;
  }
}

#############################################################
# generate_dependency_map()
#############################################################
sub generate_dependency_map()
{
  print "\nGenerating dependency map\n";
  my $fname = $pkgName . "_" . $Version . ".d";
  open (DEPENDENCY_MAP, ">$OutputDirectory/$fname")
    or die "Could not open $OutputDirectory/$fname";
  print DEPENDENCY_MAP "$OutputDirectory/$fname: \\\n";
  for my $f (sort keys %PackagedFiles)
  {
    print DEPENDENCY_MAP "\t$f \\\n";
  }
  print DEPENDENCY_MAP "\n";
  close DEPENDENCY_MAP;
}

#############################################################
# handle_scripts()
#############################################################
sub handle_scripts
{
  my $ScriptsDirectory="$PackagingDirectory/$scripts_default";
  print "\nChecking for packaging scripts in: $ScriptsDirectory\n";

  # These are the packaging script files we look for and add to the spec
  my @Scripts=('preinstall','postinstall','preremove','postremove');

  foreach my $Script (@Scripts)
  {
      my $ScriptFile=$ScriptsDirectory . "/" . $Script;
      printf("  %-15s", "$Script -> ");
      if (-f $ScriptFile)
      {
          # Script exists. Read it into a hash used later when writing the specfile.
          print "[OK]\n";

          # Check for manual swami registrations, if .0 version
          if ($Version =~ /\.0$/)
          {
            `sed -e 's/#.*//' $ScriptFile | grep -q '/usr/local/bin/swami\>'`;
            if ($? == 0)
            {
                $Errors .= "Manual swami command found in $ScriptFile\n";
                # Keep going to look for other registrations. We'll die later.
            }
          }

          # TODO, put error checking in here and clean up a bit
          my $ScriptInfo = <SCRIPT>;
          my $ScriptInfo = `cat $ScriptFile`;
          $ScriptData{$Script} = $ScriptData{$Script} . $ScriptInfo;
      }
      else
      {
          print "[None]\n";
      }
  }
}


#############################################################
# check_for_errors()
#############################################################
sub check_for_errors
{
  if ($Errors)
  {
    print "\nThe following errors were noted:\n\n";
    print $Errors;
    die "\nErrors found, cannot continue!\n";
  }
  else
  {
    return $TRUE;
  }
}


#############################################################
# get_pkg_attributes()
#    Read packageMapping.list
#############################################################
sub get_pkg_attributes()
{
    if($swamiOutput or $HTMLOutput or $ShowMacros)
    {
        # We're not actually building a package, just displaying macros.
        $PkgRolesPecs{'*'}{'*'}++;
        return;
    }

    # Nothing to do in HA, since there's no packageMapping.list there.
    if ($PRODUCTID eq "ha")
    {
        $FinalPkgName = $pkgName . "_$Architecture";
        if ($PkgTarget ne "*")
        {
            $FinalPkgName .= "_$PkgTarget";
        }
        # For bintap type patches, the parcel name should contain
        # _TAP_$bintapVersion at the end.
        # This is used to have unique parcel names.
        if (defined $ENV{'USE_BINTAP_NAME'})
        {
            $FinalPkgName .= $ENV{'USE_BINTAP_NAME'};
        }
        printf "Final Package Name: $FinalPkgName\n";
        $PkgRolesPecs{'*'}{'*'}++;
        return;
    }

    if ($ENV{USE_PKGMAPFILE} eq "")
    {
        $Errors .= "\n\tThe packageMapping.list file must be specified in the USE_PKGMAPFILE variable.\n";
        return;
    }

    # Call parsePkgMapping() to read the contents of packageMapping.list into
    # the nested hash structure.

    if (parsePkgMapping($Architecture, $ENV{USE_PKGMAPFILE}, \%pkgmap) != 0)
    {
        $Errors .= "\n\tFailed to parse packageMapping: $ENV{USE_PKGMAPFILE}\n";
        return;
    }

    if (!defined $pkgmap{$pkgName})
    {
        # For now, we'll allow uncofigured packages. At some point, this
        # really should break the package build, though.
        # Unless the package being built is an API package.

        print "**** No entry in packageMapping.list for package: $pkgName\n";

        # Don't create .map file for packages that don't exist in the %pkgmap
        if (!$DontCreateMapFile)
        {
            print "**** Bypassing mapfile creation.\n";
            $DontCreateMapFile = 1;
        }

        # default to "common" package
        $FinalPkgName = $pkgName . "_$Architecture";
        if ($PkgTarget ne "*")
        {
            $FinalPkgName .= "_$PkgTarget";
        }
        $PkgRolesPecs{'*'}{'*'}++;
        $PkgLayer = "";

        if ($PRODUCTID eq "Siren")
        {
            $PkgLayer = "CNP";
            $FinalPkgName .= "_CNP";
        }
        # For bintap type patches, the parcel name should contain
        # _TAP_$bintapVersion at the end.
        # This is used to have unique parcel names.
        if (defined $ENV{'USE_BINTAP_NAME'})
        {
            $FinalPkgName .= $ENV{'USE_BINTAP_NAME'};
        }
        print "**** FinalPkgName = $FinalPkgName\n";
        return;
    }

    # There should be only one "layer" for this package
    if (scalar (keys %{$pkgmap{$pkgName}} > 1))
    {
        $Errors .= "\n\tPackage $pkgName is defined in multiple layers in $ENV{USE_PKGMAPFILE}\n";
        return;
    }

    $PkgLayer = (keys %{$pkgmap{$pkgName}})[0];

    if (!defined $pkgmap{$pkgName}{$PkgLayer}{$Architecture}{$PkgTarget})
    {
        print "***** \"$pkgName\" \"$PkgLayer\" \"$Architecture\" \"$PkgTarget\"";

        # Don't create .map file for packages that don't exist in the %pkgmap
        if (!$DontCreateMapFile)
        {
            print "**** Bypassing mapfile creation.\n";
            $DontCreateMapFile = 1;
        }

        my $errorMsg;
        if ($PkgTarget ne "*")
        {
            $errorMsg = "Package is building for target, but is likely configured for family.\n";
        }
        else
        {
            $errorMsg = "Package is building for family, but is likely configured for target.\n";
        }

        print "**** Did not find corresponding entry in packageMapping.list for $pkgName\n";

        # If this is a VSE thirdparty package, we'll treat it as an
        # unconfigured package. Otherwise, it's a failure.
        if (($PRODUCTID eq "Siren") && ($FilelistDirectory =~ m#$ENV{TOPDIR}/thirdparty#))
        {
            # default to "common" package
            $FinalPkgName = $pkgName . "_$Architecture";
            if ($PkgTarget ne "*")
            {
                $FinalPkgName .= "_$PkgTarget";
            }
            $PkgRolesPecs{'*'}{'*'}++;

            if ($PkgLayer ne "")
            {
                $FinalPkgName .= "_$PkgLayer";
            }

            print "**** $errorMsg";
            print "**** FinalPkgName = $FinalPkgName\n";
        }
        else
        {
            $Errors .= "\n\t$errorMsg";
        }

        return;
    }

    my @pairs = ();
    for my $role (keys %{$pkgmap{$pkgName}{$PkgLayer}{$Architecture}{$PkgTarget}})
    {
        for my $pec (keys %{$pkgmap{$pkgName}{$PkgLayer}{$Architecture}{$PkgTarget}{$role}})
        {
            $PkgRolesPecs{$role}{$pec}++;
            push @pairs, "$role/$pec";
        }
    }

    print "Package attributes:\n";
    print "\tName: $pkgName\n";
    print "\tLayer: $PkgLayer\n";
    print "\tTarget: $PkgTarget\n";
    print "\tRole/Pec: ", (join ",", @pairs), "\n";

    # If PkgRolesPecs is empty at this point, there's a configuration issue
    if (scalar keys %PkgRolesPecs == 0)
    {
        $Errors .= "\n\tPackage $pkgName is misconfigured. Role and/or pec list is empty\n";
    }
}


#############################################################
# checkDisplayOpts()
#   Handle the special cases where data is being output
# without building a package.
#############################################################
sub checkDisplayOpts
{
    if ($ShowMacros)
    {
        print "\n\npkgtool supports the following macros:\n\n";

        # Display the non-install macros first
        foreach my $Macro (sort keys %PathMacros)
        {
            next if (defined $InstallMacros{$Macro});

            # Skip the "current_arch" ones
            my $skip = "$Architecture" . "_";
            next if ($Macro =~ /^$skip/);

            my $MacroVariable="\$\{" . $Macro . "\}";
            my $MacroPath=$PathMacros{$Macro};
            printf "  %-14s %-30s = %s\n",
                "Macro:",
                $MacroVariable,
                $MacroPath;
            #print "\tMacro: $MacroVariable\t= $MacroPath\n";
        }

        # Display the install macros
        print "\n";
        foreach my $Macro (sort keys %PathMacros)
        {
            next if (!defined $InstallMacros{$Macro});

            # Skip the "current_arch" ones
            my $skip = "$Architecture" . "_";
            next if ($Macro =~ /^$skip/);

            my $MacroVariable="\$\{" . $Macro . "\}";
            my $MacroPath=$PathMacros{$Macro};
            printf "  %-14s %-30s = %s\n",
                "Install Macro:",
                $MacroVariable,
                $MacroPath;
            #print "\tInstall Macro: $MacroVariable\t= $MacroPath\n";
        }

        exit;
    }

    if ($HTMLOutput)
    {
        open (HTML,"> $HTMLOutput");
        print HTML "<html>\n";
        print HTML "  <head>\n";
        print HTML "  </head>\n";
        print HTML "<br>pkgtool supports the following macros:\n";
        print HTML "<table border=\"1\">\n";
        print HTML "<tr><th>Macro Variable</th><th>Macro Data</th></tr>\n";

        foreach my $Macro (sort keys %PathMacros)
        {
            # Skip the "current_arch" ones
            my $skip = "$Architecture" . "_";
            next if ($Macro =~ /^$skip/);

            my $MacroVariable="\$\{" . $Macro . "\}";
            my $MacroPath=$PathMacros{$Macro};
            print HTML "<tr><td>$MacroVariable</td><td>$MacroPath</td></tr>\n";
        }
        print HTML "</table>\n";
        print HTML "</html>\n";
        close(HTML);
        exit;
    }

    if ($swamiOutput)
    {
        print "Outputing macros to swami file: $swamiOutput\n";

        # Instead of using the current time for the timestamp, hardcode to
        # 1 (as a small, non-zero value). We shouldn't use the current system
        # time, as it could be completely skewed from the system the software
        # will be running on.
        #
        my $Timestamp = 1;

        open (SWAMI,"> $swamiOutput");
        #timestamp::id::active::release::pec::value::informationType::keyID::key::keyVersion::visible::command::number::startDate::stopDate
        print SWAMI $Timestamp . "::0::(null)::(null)::(null)::(null)::swami_timestamp::0::(null)::(null)::(null)::(null)::0::(null)::(null)\n";
        print SWAMI $Timestamp . "::1::Y::" . $VSE_RELEASE . "::(null)::(null)::load_version::0::cnp::" . $Version . "::(null)::(null)::0::(null)::(null)\n";

        my $ID=2;
        foreach my $Macro (sort keys %PathMacros)
        {
            #timestamp::id::active::release::pec::value::informationType::keyID::key::keyVersion
            my $MacroPath=$PathMacros{$Macro};
            if (($MacroPath =~ m#^/vob#) ||
                ($Macro eq "objpath")    ||
                ($Macro =~ m/_sysroot$/))
            {
                # Skip the macros that appear to be ClearCase-specific
                next;
            }
            if ($MacroPath eq "")
            {
                $MacroPath="(null)";
            }
            print SWAMI $Timestamp . "::" . $ID . "::(null)::" . $VSE_RELEASE . "::(null)::" . $MacroPath . "::pkgtool_macro::0::" . $Macro . "::(null)::(null)::(null)::0::(null)::(null)::Siren::" . $VSE_RELEASE . "\n";
            $ID++;
        }

        close(SWAMI);
        exit;
    }
}


#############################################################
# initializeGlobals()
#############################################################
sub initializeGlobals
{
    %DefinitionTagHash = ();
    %PathMacros = ();
    %InstallMacros = ();
    %runtimeTranslations = ();

    $FileAttributeData = "";
    @CopyFiles = ();
    %ScriptData = ();
    @LinkData = ();
}

#######################################################################
# Main
#######################################################################
# If we're asked for help, display the help and exit right away
if ($HelpOptionSet)
{
  &showHelp;
  exit;
}

print "\nUsing pkgtool $pkgtoolVersion\n";
print "\n=====================================================\n";
print "STAGE 1: Examining packaging source...\n";
print "=====================================================\n";
set_defaults();
check_for_errors();

parse_definition();
check_for_errors();

$pkgName = $OrigDefinitionTagHash{"pkg_name"};
$pkgType = $OrigDefinitionTagHash{"type"};
if (($pkgName =~ /^baseline/) xor ($pkgType eq "parcel_baseline"))
{
        print "Pkg names starting with 'baseline_' are reserved for pkg type: parcel_baseline. Pkg: $pkgName\n";
        exit 1;
}

loadHandlers();
check_for_errors();

get_pkg_attributes();
check_for_errors();

# The package may have multiple roles/pecs, so loop over the values
for $PkgRole (sort keys %PkgRolesPecs)
{
    for $PkgPec (sort keys %{$PkgRolesPecs{$PkgRole}})
    {
        # Reset certain globals
        initializeGlobals();

        # If the package being built was not configured in packageMapping.list,
        # get_pkg_attributes would have set FinalPkgName to a default value.
        # So we'll check to see if this package is defined in the pkgmap hash.
        #
        if (defined $pkgmap{$pkgName}{$PkgLayer}{$Architecture}{$PkgTarget}{$PkgRole}{$PkgPec}{'NAME'})
        {
            buildFinalPkgName();
        }

        # The values of the path macros are dependent on the configuration
        # attributes of the package being built, so we'll reload the macros.
        read_macros();
        check_for_errors();

        # Now we can do substitutions in the definition data
        dereference_definition_values();
        definition_tags_to_path_macros();

        checkDisplayOpts();

        parse_filelists();
        check_for_errors();

        # STARTING WORK AREA NOW
        # Set up the packaging area
        print "\n=====================================================\n";
        print "STAGE 2: Creating buildroot, macros, specfile/rpm...\n";
        print "=====================================================\n";
        create_buildroot();
        check_for_errors();

        # Give the user a custom rpmmacros file for this packaging job
        setup_rpmmacros();
        check_for_errors();

        # Now set up the rpmrc file
        # NOTE: we use information from the macros so don't chage the order
        #       in which setup_rpmmacros() and setup_rpmrc() run
        setup_rpmrc();
        check_for_errors();

        handle_scripts();
        check_for_errors();

        write_specfile();
        check_for_errors();


        if ($Wrapit)
        {
          if(!mkpath($WrapitFromDir))
          {
              $Errors .= "\n\tCould not create dir: $WrapitFromDir\n";
          }
        }
        check_for_errors();

        build_rpm();
        check_for_errors();

        generate_dependency_map();
        check_for_errors();

        if ($Wrapit)
        {
           print "\n=====================================================\n";
           print "STAGE 3: Creating parcel(s)...\n";
           print "=====================================================\n";
           my $WrapitDefinitionFile="$PackagingDirectory/$DefinitionName";

           # Check for the package definition file.
           if (!-f $WrapitDefinitionFile)
           {
              $Errors .= "\n\tDefinition file: $WrapitDefinitionFile could not be found.\n";
              # Remove the directory before check_for_errors() exits
              rmtree($WrapitFromDir);
           }
           check_for_errors();

           print "Executing: $WrapitTool -a $Architecture -T $PkgTargetName -m $WrapitDefinitionFile -d $WrapitFromDir -o $OutputDirectory\n"; 
           system("$WrapitTool -a $Architecture -T $PkgTargetName -m $WrapitDefinitionFile -d $WrapitFromDir -o $OutputDirectory");
           if (!$? == 0)
           {
              print <<ENDWARN;

***********************************************************
***********************************************************
***********************************************************
Failure returned from wrapit tool.  This package was built,
but not properly. If error checking were turned on for
the wrapit packaging tool, this loadbuild would fail.
Please correct the errors.
***********************************************************
***********************************************************
***********************************************************
ENDWARN

              #$Errors .= "\n\tFailure returned from wrapit tool - cannot continue:\n";
           }

          if(!rmtree($WrapitFromDir))
          {
              $Errors .= "\n\tCould not delete wrapit dir: $WrapitFromDir\n";
          }
        }
        check_for_errors();

        # STARTING CLEANUP NOW
        print "\n=====================================================\n";
        print "Starting cleanup...\n";
        print "=====================================================\n";

        # Checking rmtree's return code had odd behaviour occaisionally.
        # It would report failure, but successfully delete the directory
        # (for 1 of many many cases)
        # I suspect ClearCase.
        if (-d $BuildrootDirectory)
        {
          rmtree($BuildrootDirectory);
          if (-d $BuildrootDirectory)
          {
              $Errors .= "\n\tCould not delete buildroot dir: $BuildrootDirectory\n";
          }
        }
        check_for_errors();

        # Checking rmtree's return code have odd behaviour occaisionally
        # It would report failure, but successfully delete the directory
        # (for 1 of many many cases)
        # I suspect ClearCase.
        if (-d $TemporaryDirectory)
        {
          rmtree($TemporaryDirectory);
          if (-d $TemporaryDirectory)
          {
              $Errors .= "\n\tCould not delete temp dir: $TemporaryDirectory\n";
          }
        }
        check_for_errors();

        print "\npkgtool: No errors were noted.\n";
    }
}

