#!/usr/bin/perl
###############################################################
###############################################################

#     #                                                   ###
#  #  #    ##    #####   #    #     #    #    #   ####    ###
#  #  #   #  #   #    #  ##   #     #    ##   #  #    #   ###
#  #  #  #    #  #    #  # #  #     #    # #  #  #         #
#  #  #  ######  #####   #  # #     #    #  # #  #  ###
#  #  #  #    #  #   #   #   ##     #    #   ##  #    #   ###
 ## ##   #    #  #    #  #    #     #    #    #   ####    ###

###############################################################
#
# This file should only be updated by the USM team.
# http://wiki.us.nortel.com/twiki/bin/view/Siren/WhoIsUSM
#
# Modifications to this file affect EVERYBODY!
#
###############################################################

use strict;
use warnings 'all';
use English;
use File::Basename;
use File::Path;
use File::Copy;
use POSIX qw(getcwd);
use POSIX;
use Data::Dumper;
use Getopt::Long;
use XML::DOM;
use threads;
use Cwd qw(abs_path);

BEGIN {
    if ((defined($ENV{patch_VSE_PATCH_TOOLS_PATH})) &&
        ($ENV{patch_VSE_PATCH_TOOLS_PATH} ne ""))
    {
        if (! -d "$ENV{patch_VSE_PATCH_TOOLS_PATH}")
        {
            die "The $ENV{patch_VSE_PATCH_TOOLS_PATH} is not a directory\n\n";
        }
        unshift @INC, $ENV{'patch_VSE_PATCH_TOOLS_PATH'};
    }
    else
    {
        die "The VpUtils library path: patch_VSE_PATCH_TOOLS_PATH env variable must be defined\n\n";
    }
}

use VpUtils::VpStreamInfo;
use VpUtils::VpPackage;
use VpUtils::VpGenUtils;
use VpUtils::VpPatchDep;
use VpUtils::VpPatchXml;

# Set autoflush on STDOUT
$| = 1;

#
# Declare globals
#

# Command line arguments
use vars qw (
    $xmlfile
    $bintapControlFile
    $outdir
    $logdir
    $patchdir
    $updateVersionFile
    $trace
    $buildType
    $justAdmindata
    $nocleanup
    $info
    $help
);

# Constants (and semi-constants...)
use vars qw (
    $tool
    $MERGEPATCH
    $tmpdir
    $ubuild
    $bintapVersionFile
    $rpmVersionFile

    @allfamilies
    @alltargets
    @requiredEnvVariables
    @requiredNcglEnvVariables
    @requiredStreamTags
    @nonNcglStreamTags

    %pkgmap
    %supportedFamilies
    %supportedTargets
    %validFT
    %buildLogFiles
);

# Stream specific variables
use vars qw (
    %streamData

    $pkgMapFile 
    $pkgtoolConfigDir
    $pkgtoolBinDir
    $xmlValidator
    $mungeEm
    $vsepatchSchema
);


# Globals
use vars qw (
    $ct
    $patchid
    $xml_validated
    $bintap_version
    $outfile
    $lastProgressFlagPrefix
    $outdir
    $date
    $current_view
    $patchWorkingDir
    $pkgtoolVersion
    $debuglevel
    $bbp_logFH
    $bbp_logfile
    $patch_type

    %builtKR
    %builtBintaps
    %ignorePatches
    %existingBintapPatches
    %requiredPatches
    %nclPatchMap
    %nclmap
    %bintap_info
    %pkgs
    %pkg_version
    %productComponents
    %admindata  
    %patchVerData

    @requiredBintapControlFileFields
    @parcels
    %patchInfo
);

# Global variables that are required to use path_macro utilities.
use vars (
    '%PathMacros',                # Available macros, dynamically loaded.
    '%InstallMacros',             # Subset of macros used for install paths.
    '%SwamiMacros',               # Subset of macros for swami registrations
    '%runtimeTranslations',       # Mapping of install paths to runtime paths.
);

# Initialize constants and global variables
sub initGlobalVars()
{
    $tool = basename($0);

    # The following environment variables are required, at a minimum.
    # Will get these from the setup.sh files of each stream.
    @requiredEnvVariables = qw (
        patch_BLADES_CONFIG
        ntmkbw_VSE_RELEASE 
        patch_TARGOBJDIR_PATTERN
        patch_CPPAT_PATCH_TOOLS_PATH
        patch_VSE_PATCH_TOOLS_PATH
    );
   validateRequiredEnvVars(\@requiredEnvVariables);

    use constant DEBUG_LEVEL_0 => 0;
    use constant DEBUG_LEVEL_1 => 1;
    use constant DEBUG_LEVEL_2 => 2;
    use constant DEBUG_LEVEL_3 => 3;
    use constant DEBUG_LEVEL_4 => 4;

    use constant BBP_RC_OK             => 0;
    use constant BBP_RC_INVALID_PARM   => 1;
    use constant BBP_RC_CC_ERROR       => 2;
    use constant BBP_RC_FILE_NOT_EXIST => 3;
    use constant BBP_RC_DIR_NOT_EXIST  => 4;
    use constant BBP_RC_CS_FAILED      => 5;
    use constant BBP_RC_ERROR          => 6;

    use constant BUILD_TYPE_VSEPATCH => "VSEPATCH";
    use constant BUILD_TYPE_EBUILD   => "EBUILD";
    use constant BUILD_TYPE_DESIGN   => "DESIGN";

    $debuglevel = defined $ENV{DEBUG_LEVEL}
                ? $ENV{DEBUG_LEVEL}
                : DEBUG_LEVEL_0;

    # Initialize $buildType as 'DESIGN'
    $buildType = BUILD_TYPE_DESIGN;

    use constant FLAG_NOT_STARTED => "notstarted";
    use constant FLAG_IN_PROGRESS => "inprogress";
    use constant FLAG_FAILED      => "failed";
    use constant FLAG_COMPLETED   => "completed";

    $patch_type = "bintap_patch";
 
    $ct = "/usr/atria/bin/cleartool";
    
 
    @requiredStreamTags = qw (
        LOADBUILD_OBJECT_DIR
        BUILD_SETUP
        FINAL_COMPILE_DIR
    );
    
    @nonNcglStreamTags = qw (
        NCLMAPPING_LIST
        BUILD_VERSION
        PACKAGEMAPPING_LIST
    );
    
    
    
    # The following environment variables are required, at a minimum.
    # Will get these from the setup.sh files of each stream.
    @requiredNcglEnvVariables = qw (
        patch_NCGLHA_TARGOBJDIR_PATTERN
    );

    @requiredBintapControlFileFields = ('bintap_info',
                                        'bintap_version');

    chomp ($tmpdir = `mktemp -d -p  /tmp buildBintapPatch.XXXXXX`);
    report_error_and_exit(BBP_RC_DIR_NOT_EXIST, "Unable to create working directory.")
        if (! -d $tmpdir);

    # Initialize Bintap Patch variables
    $bintap_version = '';
    %bintap_info = ();
    $xml_validated = 0;
    %pkgs = ();
    $patchWorkingDir = "$ENV{HOME}/.vsepatch";

    # Initialize ENV vars
    if (!defined $ENV{USE_SRC_ROOT})
    {
        $ENV{USE_SRC_ROOT} = "";
    }

    $ubuild = "ubuild";
    chomp($date = `date`);
    $date =~ s/\s//g;

    # Determine the config dir
    $pkgtoolBinDir = dirname(abs_path($0));

    $pkgtoolConfigDir = (-d "$pkgtoolBinDir/config")
                      ? "$pkgtoolBinDir/config"
                      : "$pkgtoolBinDir/../config";

    require "$pkgtoolConfigDir/pkgutils.pm";
    require "$pkgtoolConfigDir/path_macros";

    # pkgtoolVersion must be aligned with the other pkgtools
    $pkgtoolVersion = "8.0.3";

    $vsepatchSchema = $pkgtoolConfigDir . "/vsePatch.xsd";
    $xmlValidator = (defined $ENV{XML_VALIDATOR_PATH})
                        ? "$ENV{XML_VALIDATOR_PATH}/bin/validateXml"
                        : "$ENV{USE_SRC_ROOT}/vobs/lsba_platform_tools/xml_validator/bin/validateXml";

    $mungeEm = "$pkgtoolBinDir/mungeEm";
    $MERGEPATCH = "$pkgtoolBinDir/mergepatch";
} 

#
# showHelp:
#
#    Display the help message
#
sub showHelp
{
    print STDERR <<OUT;

Using $tool version $pkgtoolVersion

Syntax: $tool <arguments>
Where arguments are required, optional:

Required:
    --bintap-control-file <arg>  : Bintap Control file. (<patchid>.bintap)
    --xmlfile <arg>              : Patch xml file.

Optional:
    --output <arg>               : output directory for patch. 
                                   Default is current directory.
    --logdir <arg>               : write build output to a logdir, along with
                                   progress flags. Default is current directory.
    --generate-admindata         : Skip the parcel build stage and just produce
                                   an admindata file. Used to aid in building
                                   bintap patches.
    --update-version-file        : Automatically update the version file
                                   upon success (should only be used by eBuild,
                                   unless using a private version file)
    --build-type <arg>           : Three options: vsepatch, ebuild or design.
                                   Default value is 'design'
    --patchdir <arg>             : Directory to search for pre-existing patches
                                   and when build-type is design or vsepatch,
                                   to place the patch data file after successful builds.
    --nocleanup                  : By default, the working directories are cleaned up after a successful build
                                   when nocleanup is set they are not cleaned up.
    --trace                      : Enable the debug logs in Code Section Creation tools (PMCPRE)
    --help                       : Shows help
     
OUT
    exit BBP_RC_ERROR;
}


#
# The "END" is a special sub-routine that allows us to do some special handling
# when the script exits. This is called when either exit or die are called,
# and gives us a single place where we can clean up the temporary directory.
# This is analogous to doing a "trap on exit" in bash.
#
END
{
    # Save last rc, and exit with it, below.
    my $rc = $?;

    if (($tmpdir) && (-d $tmpdir))
    {
        `rm -rf $tmpdir`;
    }

    if ($rc != 0)
    {
        print "\n";
        if ($bbp_logfile && -f $bbp_logfile)
        {
           print "Please review the $tool logs at:\n";
           print "$bbp_logfile\n";
        }
    }

    close $bbp_logFH if ($bbp_logFH);

    # Check to see if the last flag has been left as in-progress. If so,
    # mark it failed.

    if (($lastProgressFlagPrefix) && (-f $lastProgressFlagPrefix.FLAG_IN_PROGRESS))
    {
        rename $lastProgressFlagPrefix.FLAG_IN_PROGRESS,
               $lastProgressFlagPrefix.FLAG_FAILED;
    }
    
    $? = $rc;
}

# Catch interrupts to ensure the tmpdir is cleaned.
# This will result in "die" being called, which in turn will call "END" above.
use sigtrap qw(die normal-signals);

#
# announce:
#
#    Displays messages to the console with a timestamp.
#
# Parameters:
#    message string
#
sub announce($)
{
    my $msg = shift;
    my @now = localtime;
    printf "%02d:%02d:%02d - %s",
           $now[2], $now[1], $now[0], $msg;
}

# Always exits with error $rc
# exit($rc);
sub report_error_and_exit($$)
{
    my $rc = shift;
    my $msg = shift;

    VpUtils::VpGenUtils::report_error_and_exit($rc, $msg, $bbp_logFH);
}

sub exit_if_failure($)
{
    my $msg = shift;
    my $rc = $?>>8;

    if ($rc != 0)
    {
        report_error_and_exit($rc, "$msg");
    }
}

sub printToLogFile
{
    my $msg          = shift;
    my $debug_level  = shift;

    my @now = localtime;

    $debug_level = DEBUG_LEVEL_0
        if (!$debug_level);

    if ($debuglevel >= $debug_level)
    {
        if ($bbp_logFH)
        {
            printf $bbp_logFH "%02d:%02d:%02d - %s\n",
                           $now[2], $now[1], $now[0], $msg;
        }
        else # if log file handler is null, print to screen.
        {
            printf "%02d:%02d:%02d - %s\n",
                    $now[2], $now[1], $now[0], $msg;
        }
    }
}

sub validateAndProcessInputVars()
{
    #
    # Validate the arguments
    #
    report_error_and_exit(BBP_RC_INVALID_PARM, "The patch input file must be specified with --bintap-control-file.")
        if (! $bintapControlFile);
    
    report_error_and_exit(BBP_RC_INVALID_PARM, 
              "The specified file, $bintapControlFile, does not exist or is not readable.")
        if (! -r $bintapControlFile);
    
    report_error_and_exit(BBP_RC_INVALID_PARM, "The patch xml file must be specified with --xmlfile.")
        if (! $xmlfile);
    
    report_error_and_exit(BBP_RC_INVALID_PARM, "The specified file, $xmlfile, does not exist or is not readable.")
        if (! -r $xmlfile);
    
    report_error_and_exit(BBP_RC_INVALID_PARM, "$outdir does not exist or is not writeable.")
        if ($outdir && ((! -d $outdir) || (! -w $outdir)));
    
    report_error_and_exit(BBP_RC_INVALID_PARM, "$logdir does not exist or is not writeable.")
        if ($logdir && ((! -d $logdir) || (! -w $logdir)));
    
    $buildType = uc($buildType);
    announce "Running Build for \'$buildType\'\n";
    
    announce "Validating input parameters.\n";
    %bintap_info = validateBintapContolFile($bintapControlFile);
    
    $bintap_version = $bintap_info{'bintap_version'}[0];
    
    if (!$outdir)
    {
        $outdir = $ENV{HOME} . "/.vsepatch";
    }
    # Let's create the output directory to put the logs, code sections, etc in.
    mkpath($outdir) unless (-d $outdir);
    
    
    # If patchdir is specified, use patchdir, otherwise put it in outdir
    if ($ENV{'BUILDBINTAP_PATCH_DIR'})
    {
        $patchdir = $ENV{'BUILDBINTAP_PATCH_DIR'};
    }

    # If the patchdir is not specified, we will use outdir
    if (!$patchdir)
    {
        $patchdir = "$outdir";
    }
    mkpath($patchdir) unless (-d $patchdir);

    if (!$logdir)
    {
        $logdir = "$outdir/logs";
    }
    mkpath($logdir) unless (-d $logdir);

    # Find out current view
    $current_view = `$ct lsview -s -cview`;
    exit_if_failure("Failed to determine the current view");

    report_error_and_exit(BBP_RC_INVALID_PARM, "Failed to determine current view.")
        if (! $current_view);
    chomp($current_view);
    printToLogFile("Current view: $current_view.");
    
    # Find out if the specified logdir and outdir are in clearcase or not
    # If they are in clearcase, we will need to append /view/<current_view> to the
    # beginning
    # Non-MVFS is set when it is not clearcase dir
    if ($logdir)
    {
        my $ret = `$ct describe $logdir |grep Non-MVFS`;
        if (!$ret)
        {
            $logdir = "/view/$current_view" . "$logdir";
        }
    }
    
    if ($outdir)
    {
        my $ret = `$ct describe $outdir |grep Non-MVFS`;
        if (!$ret)
        {
            $outdir = "/view/$current_view" . "$outdir";
        }
    }

    # get rid of all but the last 10 logs...
    my @keeplogs  = `sh -c "ls -rt $logdir/$tool.*.log 2>/dev/null" `;
    my $count = scalar @keeplogs;
    foreach (`sh -c "ls -rt $logdir/$tool.*.log 2>/dev/null "`)
    {
        if ($count <= 10)
        {
            last;
        }
        `rm $_`;
        $count = $count - 1;
    }

    $bbp_logfile = "$logdir/$tool.$date.log";

    if (-r $bbp_logfile)
    {
        `rm $bbp_logfile 2>&1`;
    }

    # bbp_logFH handler is closed in END proc when we die or complete successfully.
    open $bbp_logFH, ">$bbp_logfile" or warn("Unable to create session log: $!");
    
}


# waitForThreads
#
#    Waits for completion of all threads, and returns a count of the number
#    of threads that returned with a non-zero status.
#
sub waitForThreads
{
    my $errors = 0;
    for my $thr (threads->list())
    {
        my $rc = $thr->join();
        if ($rc != 0)
        {
            $errors++;
            printToLogFile("An error occured in the threads.");  
        }
    }
    return $errors;
}


sub startView($)
{
   my($view) = shift;
   my($rc);

   system("$ct startview $view");
   exit_if_failure("Unable to start the build view, $view.");

   return;
}

# 
# createCodeSections
#   
#     Sets the required env variables and creates the code sections
#
# Parameters:
#     build control file name (full path)
#
sub createCodeSections($$)
{
    my $stream = shift;
    my $build_control_file = shift;
    my $rc;

    my $pmcpre_logfile = "$logdir/vsePatchCreate.$stream.$date.log";

    # Establish the patch build environment.
    if (!$ENV{'PATCH_ENVIRONMENT'})
    {
        $ENV{'PATCH_ENVIRONMENT'} = 'LATEST';
    }

    # For Debugging patch creation issues,
    if ((!defined($ENV{'PATCH_PRINT_TRACE_MESSAGES'})) && $trace)
    {
        $ENV{'PATCH_PRINT_TRACE_MESSAGES'} = 'DEBUG_CREATE';
        print "Setting trace messages to $ENV{'PATCH_PRINT_TRACE_MESSAGES'}\n";
    }

    # Remove all of the code sections in the current directory so that the
    # list after the creation call will be accurate.
    system('rm -f *.cs* *.patch_info');
    exit_if_failure("Failed to clean up the patch files in " . getcwd() . " directory.");

    eval `$ENV{'patch_CPPAT_PATCH_TOOLS_PATH'}/cppat_setup perl`;
    open my $pmcpre_logFH, ">$pmcpre_logfile" or warn("Unable to create session log: $!");
    runCmdOnScreen($pmcpre_logFH,
                   "vsePatchCreate",
                   "\nFailed to create patch code sections.\n", 
                   "vsePatchCreate $build_control_file 2>&1");
    if ($? != 0)
    {
        close $pmcpre_logFH;
        print "Please review the code section creation logs at:\n";
        print "$pmcpre_logfile\n\n";
        exit BBP_RC_CS_FAILED;
    }
    close $pmcpre_logFH;
}


# 
# validateBintapContolFile
#
#     Parses the .bintap input file and validates all fields
#
# Input file format ($patchid.bintap):
# ------------------
# 2. bintap_info <stream> <control_file> <build_version> [milestone_view] #one for each stream
#       where:
#         stream                : ex: vse40, cavse120, ncgl120 
#         control_file          : full path patchid.control 
#         build_version         : ex: 4.0.0.084303
#         milestone_view        : the milestone view [optional if running within a view]
#
# 3. bintap_version <a unique number per patch>
# 4. KR_patches : master list of K&R patches (not very sure what I should be expecting as this parm, need to work out the details with you) 
#
sub validateBintapContolFile($)
{
  my $input_file = shift;
  my %info = ();
  my $extension;

  ParseFile($input_file, \%info);

  # Make sure input file contains all required parms
  for my $req (@requiredBintapControlFileFields)
  {
     report_error_and_exit(BBP_RC_INVALID_PARM, "The \'$req\' field must be specified.") 
        if (!defined $info{$req});
  } 

  return %info;
}

# 
# readPatchInfoFile
#
#    Reads the patch info file that is generated by VsePatchCreate
#    For a sprecified code section
#
#    Updates the requiredPatches indexed by pkgname
#
sub readPatchInfoFile($$$$)
{
    my $pif = shift;
    my $stream_info = shift;
    my $csDir = shift;
    my $patch_info = shift;

    my %file_data = ();

    ParseFile($pif, \%file_data); 
    printToLogFile("Pif File Data:\n" . Dumper(\%file_data), DEBUG_LEVEL_4);

    validatePatchInfoFields($pif, \%file_data);
    
    populateStreamInfo(\%file_data, $stream_info, $csDir, $pif); 

    # After a successful patch build,
    # we will create a data file which contains all sort of patch info.
    # Prepare the patch info here since we have parsed the pif file.
    addPifToPatchInfo($pif, \%file_data, $patch_info);
}

sub validatePatchInfoFields($$)
{
    my $pif = shift;
    my $file_data = shift;

    report_error_and_exit(BBP_RC_INVALID_PARM, "Failed to retrieve package from $pif.")
        if (!exists ($file_data->{'package'}));

    report_error_and_exit(BBP_RC_INVALID_PARM, "Failed to retrieve product_arch from $pif.")
        if (!exists ($file_data->{'product_arch'}));

    report_error_and_exit(BBP_RC_INVALID_PARM, "Failed to retrieve object_id from $pif.")
        if (!exists ($file_data->{'object_id'}));

    report_error_and_exit(BBP_RC_INVALID_PARM, "Failed to retrieve file_id from $pif.")
        if (!exists ($file_data->{'file_id'}));

    report_error_and_exit(BBP_RC_INVALID_PARM, "Failed to retrieve created_patch_file from $pif.")
        if (!exists ($file_data->{'created_patch_file'}));
}


sub populateStreamInfo($$$)
{
    my $file_data = shift;
    my $stream_info = shift;
    my $csDir = shift;
    my $pif = shift;
  
    my ($family, $targetName, $pkgname);

    $pkgname = $file_data->{'package'}[0];

    my $product_arch = $file_data->{'product_arch'}[0];
    if ($product_arch =~ /^(.*)\.(.*)$/)
    {
        $family = $1;
        $targetName = $2;
    }
    else
    {
        report_error_and_exit(BBP_RC_INVALID_PARM, "Unknown product_arch format in $pif: $product_arch");
    }

    my $target = ($targetName eq "fam") ? "*" : $targetName;

    if (!$pkgmap{$pkgname})
    {
        # api packages are not delivered to the field.
        # They are only created to be used by other layers
        if ($pkgname =~ /^api-/)
        {
            printToLogFile("$pkgname package is not delivered to the field. Skipping...");
            # vsePatchCreate does not have access to the packageMapping list when
            # creating the code sections.
            # It creates code sections for all bintappable packages.
            # This tool is responsible to filter out the packages that don't
            # exist in packageMapping.list.
            return;
        }
        else
        {
            report_error_and_exit(BBP_RC_INVALID_PARM, 
                                  "$pkgname does not exist in the $pkgMapFile");
        }  
    }

    # Validate that this package for this family/target exists 
    # in the packageMapping.list file
    # Determine the source layer
    my $layer = determineLayer($pkgMapFile, \%pkgmap, $pkgname);
    if (!$pkgmap{$pkgname}{$layer}{$family}{$target})
    {
        printToLogFile("$pkgname package is not supported for $family/$target architecture.");
        # Just skip this family/target. 
        # vsePatchCreate does not have access to the packageMapping list when
        # creating the code sections.
        # It creates packages for all family/targets.
        # This tool is responsible to filter out the family/targets that don't
        # exist in packageMapping.list.
        return;
    }

    my $objectid = $file_data->{'object_id'}[0];
    my $file_id  = $file_data->{'file_id'}[0];
    my $object;
    # Object_id will be in /usr/local/bin/patchTestClient##001479531241 format
    # Need to parse this to get patchTestClient
    if ($objectid =~ /^.*\/(.*)$/)
    {
        $object = $1;
        $object =~ s/#.*//; #strip checksum.
    }
    else
    {
        report_error_and_exit(BBP_RC_INVALID_PARM, "Unknown object_id format in $pif: $objectid");
    }

    my $created_patch_file = $file_data->{'created_patch_file'}[0];
    printToLogFile("Package info from $pif file\n" .
                   "--------------------------------------------\n" .
                   "pkgname : $pkgname\n" .
                   "family  : $family\n" .
                   "target  : $targetName\n" .
                   "object  : $object\n" .
                   "cs file : $created_patch_file\n" .
                   "*******************************************", DEBUG_LEVEL_2);

    if (!exists($stream_info->{$pkgname}))
    {
        $stream_info->{$pkgname} = ();
    }

    if (!exists($stream_info->{$pkgname}{$family}))
    {
        $stream_info->{$pkgname}{$family} = ();
    }

    if (!exists($stream_info->{$pkgname}{$family}{$target}))
    {
        $stream_info->{$pkgname}{$family}{$target} = ();
    }

    # We need to rename the code section to a specific format
    my $csname = "$patchid.$pkgname.$family.$targetName.$object.cs";

    my $new_cs_dir = $tmpdir;
    copy("$csDir/$created_patch_file", "$new_cs_dir/$csname")
        or report_error_and_exit(BBP_RC_ERROR, "Failed to copy from $csDir/$created_patch_file to $new_cs_dir/$csname");
    my %codesection = ();
    $codesection{'csDir'}    = $new_cs_dir;
    $codesection{'csname'}   = $csname;
    $codesection{'objectid'} = $objectid;
    $codesection{'file_id'}  = $file_id;
    push @{$stream_info->{$pkgname}{$family}{$target}{'codesections'}}, \%codesection;

    # Right now, I am only interested in the prereq field to create the
    # requires list, later when we need more
    # we can make this part better, more generic..
    if (exists($file_data->{'prereq'}))
    {
        for my $prereq (@{$file_data->{'prereq'}})
        {
            $prereq = uc($prereq);
            $requiredPatches{$prereq}++;
            mapPatchToNcl($pkgMapFile, \%pkgmap, $prereq, $pkgname, \%nclPatchMap);
        }
    }
    printToLogFile("Stream info: \n" . Dumper($stream_info), DEBUG_LEVEL_4); 
}

sub appendPrereqInfoToSpec($$$)
{
    my $spec_file = shift;
    my $pif       = shift;
    my $arch      = shift;

    my ($rc, $cmd);

    open SPECFILE, ">>$spec_file"
        or die "Failed to open $spec_file for writing";

    printToLogFile("Adding pot_prereq_prod $arch $pif->{'cs'} to $spec_file", DEBUG_LEVEL_1);

    # To make extracting pot_prereq_prod and shadow_patch_prod from spec file
    # easier, adding a placeholder for the actual cs and shadow file dir
    # which should be replaced with the extract dir after the data file is extracted.
    print SPECFILE "pot_prereq_prod $arch REPLACE_WITH_DIR/$pif->{'cs'}\n";

    if ($pif->{'shadow'})
    {
        printToLogFile("Adding shadow_patch_prod $arch $pif->{'shadow'} to $spec_file", DEBUG_LEVEL_1);
        print SPECFILE "shadow_patch_prod $arch REPLACE_WITH_DIR/$pif->{'shadow'}\n";
    }

    close(SPECFILE);
}

# Updates patch_info
sub initPatchInfoForStream($$$$)
{
    my $stream       = shift;
    my $control_file = shift;
    my $spec_file    = shift;
    my $patch_info   = shift;

    die "initPatchInfoForStream failed: Null \'stream\'.\n"
        if (!$stream);

    die "initPatchInfoForStream failed: Null \'control_file\' for $stream.\n"
        if (!$control_file);

    die "initPatchInfoForStream failed: Null \'spec_file\' for $stream.\n"
        if (!$spec_file);

    if (!exists($patch_info->{$stream}))
    {
        $patch_info->{$stream} = ();
    }

    $patch_info->{$stream}{'control_file'} = $control_file;
    $patch_info->{$stream}{'spec_file'} = $spec_file;
}

sub addPifToPatchInfo($$$)
{
    my $pif_name = shift;
    my $pif_data = shift;
    my $stream_patch_info = shift; #UPDATES

    # pif_data fields are validated prior to this proc.
    my $spec_file = $stream_patch_info->{'spec_file'};

    my %info;
    chomp($info{'pif'} = `basename $pif_name`);
    $info{'cs'} = $pif_data->{'created_patch_file'}[0];
    if (exists $pif_data->{'shadow_patch_file'})
    {
        $info{'shadow'} = $pif_data->{'shadow_patch_file'}[0];
    }

    appendPrereqInfoToSpec($spec_file, \%info, $pif_data->{'product_arch'}[0]);

    push @{$stream_patch_info->{'pifs'}}, \%info;
}

# 
# collectResults
#
#     Checks the code section directory for the created code sections
#     Parses the code section names to get the patchid, pkgname, arch info
#     Adds it to the %bintaps hash
#
# Parameters:
#    stream string
#    code section directory
#    Updates bintaps hash with the patchid, pkgname, arch, etc info.
#
sub collectResults($$$$$)
{
    my $bintaps = shift;
    my $stream = shift;
    my $csDirectory = shift;
    my $control_file = shift;
    my $spec_file = shift;

    my $result_file = "$csDirectory/vsePatchInformation";

    # The vsePatchInformation file has the patch_info file names
    die "Failed to read $result_file file, it either does not exist or not readable\n"
        if (! -f $result_file);     

    if (!open(PATCH_INFO_FILES, $result_file))
    {
        die "\nFailed to open $result_file for reading. $!\n";
    } 

    my @patch_info_files = <PATCH_INFO_FILES>;
    close(PATCH_INFO_FILES);
    
    if (scalar @patch_info_files == 0)
    {
        die "Failed to retrive patch_info files for $stream stream\n";
    }

    if (!exists $bintaps->{$stream})
    {
        $bintaps->{$stream} = ();
    }

    initPatchInfoForStream($stream, $control_file, $spec_file, \%patchInfo);

    for my $patch_info (@patch_info_files)
    {
        chomp($patch_info);
        my $patch_info_full_path = "$csDirectory/$patch_info";
        readPatchInfoFile($patch_info_full_path, \%{$bintaps->{$stream}}, $csDirectory, $patchInfo{$stream});
    }
 
    printToLogFile("collectResults %pkgs: \n" . Dumper($bintaps), DEBUG_LEVEL_4);
    return;
}

# 
# generateStreamCodeSections
#
#     Creates a new directory for the specified stream, 
#     Creates code sections and collects the result information
#     Updates the global %pkgs hash
# 
# Parameters:
#     stream string
#     milestone view name
#     control file full path    
#
sub generateStreamCodeSections($$$$)
{
    my $stream = shift;
    my $build_view = shift;
    my $build_control_file = shift;
    my $spec_file = shift;
    
    # For each stream open a new working directory
    # The code sections will be stored in that directory
    my $orig_dir = getcwd();
    my $subdir = "$patchWorkingDir/$stream";
    mkpath $subdir unless ( -d $subdir );
    chdir($subdir) or die "Cant chdir to $subdir $!";

    if (!defined $ENV{SKIP_CODE_SECTIONS})
    { 
        createCodeSections(
            $stream, 
            $build_control_file);
    }

    collectResults(\%pkgs, $stream, $subdir, $build_control_file, $spec_file);

    chdir($orig_dir) or die "Cant chdir to $orig_dir $!";
}


# 
# setupStreamGlobals
#
#     Sets up env vars and globals for each stream
#
# Parameters:
#     stream string
#     view name
#
sub setupStreamGlobals($$$)
{
    my $stream          = shift;
    my $view            = shift;
    my $stream_data_xml = shift;

    # Get all stream info for specific stream_id or integration branch name
    my $si_g = new VpUtils::VpStreamInfo;
    my $target = $si_g->parseStreamXmlFile($stream_data_xml, $stream, \%streamData);
    for my $streamTag (@requiredStreamTags)
    {
        if (!$streamData{$target}{$streamTag})
        {
            report_error_and_exit(BBP_RC_ERROR, "Failed to read $streamTag from database.");
        }
    }

    if ($updateVersionFile)
    {
        report_error_and_exit(BBP_RC_INVALID_PARM, "The LOADBUILD_BINTAP_VERSION_FILE tag must be datafilled in $stream_data_xml.")
            if (! $streamData{$target}{LOADBUILD_BINTAP_VERSION_FILE});

        my $bintap_version_file = $streamData{$target}{LOADBUILD_BINTAP_VERSION_FILE};
        if (-e $bintap_version_file && (!-w $bintap_version_file))
        {
            report_error_and_exit(BBP_RC_INVALID_PARM,
                                  "Version file \'$bintap_version_file\' must be writeable \n" .
                                  "if --update-version-file is specified.");
        }
    }
  
    $streamData{$target}{LOADBUILD_OBJECT_DIR} = "/view/$view$streamData{$target}{LOADBUILD_OBJECT_DIR}";
    $streamData{$target}{BUILD_VIEW} = $view;

    # Used when building the path macros for bintap
    # By default it is NULL,
    # For bintap the /bintaps path is inserted before the destination path
    # Ex: /tftpboot/cnp/i686/5.0.0/family/common/bintaps/usr/local/bin/PatB_2.par_a.i686.exe_a_1.cs
  
    # For bintap type patches, the parcel name should contain
    # _TAP_$bintapVersion at the end
    # This is used to have unique parcel names
    $ENV{'USE_BINTAP_NAME'} = "_TAP_$bintap_version";
    my $tap_extension = "_TAP_$bintap_version"; 
    my $setupCmd  = $streamData{$target}{BUILD_SETUP};
    $setupCmd .= " && export USE_BINTAP=/bintaps && export USE_BINTAP_NAME=$tap_extension"; 
    $setupCmd .= " && export OBJPATH=$streamData{$target}{LOADBUILD_OBJECT_DIR}";
    $streamData{$target}{BUILD_SETUP} = $setupCmd; 

    # PACKAGE_VERSION is not a good name here
    # BUILD_VERSION is more suitable for us
    # BUILD_VERSION is the version like: 5.1.0.095103
    # PACKAGE_VERSION is the version like: 5.1.0.095103.1
    # Renaming it in the streamData
    $streamData{$target}{BUILD_VERSION} = $streamData{$target}{PACKAGE_VERSION};
    delete $streamData{$target}{PACKAGE_VERSION};

     $streamData{$target}{'logfile'} = "$logdir/$stream.$date.log";
     if (-f $streamData{$target}{'logfile'})
     { 
         system("rm $streamData{$target}{'logfile'}");  
     }

    if ($si_g->is_NCGL_stream($target))
    {
        validateRequiredEnvVars(\@requiredNcglEnvVariables);

        # For ncgl, the family, pkgmap, etc info are all in Siren vob
        # So, we are done
        printToLogFile("This is ncgl stream, no need to calculate the rest", DEBUG_LEVEL_3);
        printToLogFile("Displaying $stream stream data:\n" .
            Dumper(\%{$streamData{$target}}) . "\n", DEBUG_LEVEL_4);
        return $target;    
    }

    for my $streamTag (@nonNcglStreamTags)
    {
        if (!$streamData{$target}{$streamTag})
        {
            report_error_and_exit(BBP_RC_ERROR, "Failed to read $streamTag from database.");
        }
    }

    $pkgMapFile = $streamData{$target}{PACKAGEMAPPING_LIST};

    # Get the list of all families and targets
    open PECMAP, "$pkgtoolConfigDir/pecmap.list"
        or report_error_and_exit(BBP_RC_ERROR, "Unable to open $pkgtoolConfigDir/pecmap.list");
    while (<PECMAP>)
    {
        chomp;
        s/#.*//;
        if (/^[^:]+:[^:]+:[^:]+:([^:]+):([^:]+):/)
        {
            my $family = $1;
            my $target = $2;
            $validFT{$family}{$target}++;
        }
    }
    close PECMAP;

    #
    # Determine the list of supported families and targets
    # from the *.in configuration files.
    #
    for my $family (keys %validFT)
    {
        my $infile = $ENV{'patch_BLADES_CONFIG'} . "/fam_" . $family . ".in";
        $supportedFamilies{$family}++ if (-f $infile);

        for my $target (keys %{$validFT{$family}})
        {
            $infile = $ENV{'patch_BLADES_CONFIG'} . "/". $target . "_" . $family . ".in";
            $supportedTargets{$target} = $family if (-f $infile);
        }

    }

    @allfamilies = sort keys %supportedFamilies;
    @alltargets = sort keys %supportedTargets;

    if (scalar @allfamilies == 0)
    {
        print STDERR "No .in files were found in $ENV{'patch_BLADES_CONFIG'}.\n";
        print STDERR "Please check the patch_BLADES_CONFIG variable.\n";
        exit (1);
    }

    # Parse the packageMapping.list for each family
    for my $family (@allfamilies)
    {
        if (parsePkgMapping($family, $pkgMapFile, \%pkgmap) != 0)
        {
            report_error_and_exit(BBP_RC_ERROR, "Failed to parse $pkgMapFile");
        }
    }

    my $nclMapFile = $streamData{$target}{NCLMAPPING_LIST};
    # Parse the nclMapping.list
    if (parseNclMapping($nclMapFile, \%nclmap) != 0)
    {
        report_error_and_exit(BBP_RC_ERROR, "Could not parse $nclMapFile");
    }

    # This variable is introduced for testing REQUIRES dependencies.
    # If it is set, then we will assume all patches that exist in the version
    # files are valid patches.
    if (! defined $ENV{'NO_IGNORE_PATCHES'})
    {
        # Generate a list of patches that are:
        #   OBS or OBE or SUP or DBG or ABS categories.
        # When calculating the patch dependencies, 
        # These patches will be ignored.
        VpUtils::VpPatchDep::queryIgnorePatches(\%ignorePatches);
    }

    if ($streamData{$target}{LOADBUILD_RPM_VERSION_FILE})
    {
        my %existingPatches;
        my $excludeTxtPatches = "yes";
        %builtKR = VpUtils::VpPatchDep::read_rpm_version_file($streamData{$target}{LOADBUILD_RPM_VERSION_FILE},
                                                              $streamData{$target}{BUILD_VERSION},
                                                              \%existingPatches,
                                                              $excludeTxtPatches);
    }

    if ($streamData{$target}{LOADBUILD_BINTAP_VERSION_FILE})
    {
        %builtBintaps = VpUtils::VpPatchDep::read_bintap_version_file($streamData{$target}{LOADBUILD_BINTAP_VERSION_FILE},
                                                                    $streamData{$target}{BUILD_VERSION},
                                                                    \%existingBintapPatches);
    }
    if (scalar keys %existingBintapPatches > 0)
    {
        printToLogFile("Previously built/released patches are: \n   " . join("\n   ", keys %existingBintapPatches));
    }

    # We dont care about this case when building DESIGN patches, 
    # otherwise fail (BUILD_TYPE_VSEPATCH && BUILD_TYPE_EBUILD)
    if (($buildType ne BUILD_TYPE_DESIGN) && (defined $existingBintapPatches{$patchid}))
    {     
        report_error_and_exit(BBP_RC_ERROR, 
            "$patchid already exists in $streamData{$target}{LOADBUILD_BINTAP_VERSION_FILE}");
    }

    printToLogFile("Displaying $stream stream data:\n" . 
        Dumper(\%{$streamData{$target}}) . "\n", DEBUG_LEVEL_4);
    return $target;
}

#
# determineKNRVersion:
#
#     Determines the highest KNR parcel version of the specified package.
#
sub determineKNRVersion
{
    my $builtPkgs = shift;
    my $pkgname = shift;
    my $build_version = shift;

    report_error_and_exit(BBP_RC_INVALID_PARM, "Package name is not specified.")
        if (!$pkgname);

    report_error_and_exit(BBP_RC_INVALID_PARM, "build_version is not specified for $pkgname package.")
        if (!$build_version);

    printToLogFile("Determine KNR version input parameters:\nPkgname: $pkgname\nbuild_version: $build_version\n", 
                   DEBUG_LEVEL_2);

    # Initialize version number for packages that apply to the load itself.
    my $version = 0;

    # Determine version information.
    # Check for the highest version in the loadbuild version file.
    my @versions = VpUtils::VpGenUtils::sortHashByKeyDescendingNum($builtPkgs->{$pkgname}{$build_version});
    if (scalar @versions != 0)
    {
        # Determine dependencies, based on the highest (non-skipped) version
        for my $num (@versions)
        {
            printToLogFile("$builtPkgs->{$pkgname}{$build_version}{$num} patch is in ignore list.") 
                    if (defined $ignorePatches{uc($builtPkgs->{$pkgname}{$build_version}{$num})});

            if ((defined $builtPkgs->{$pkgname}{$build_version}{$num}) &&
                ($builtPkgs->{$pkgname}{$build_version}{$num} ne "")    &&
                (!defined $ignorePatches{uc($builtPkgs->{$pkgname}{$build_version}{$num})}))
            {
                my $req = $builtPkgs->{$pkgname}{$build_version}{$num};
                printToLogFile("Adding $req patch to the requires list.", DEBUG_LEVEL_2); 
                $requiredPatches{$req}++;
                mapPatchToNcl($pkgMapFile, \%pkgmap, $req, $pkgname, \%nclPatchMap);
                $version = $num;
                last;
            }
        }
    }
    printToLogFile("Highest K&R parcel version of $pkgname is $version.");  
    return "$build_version.$version";
}

#
# ParseFile
#
#     Parses the file fname writes it into the %info hash
#
#     The file format is as follows:
#     <line type> <line value>
#
# Parameters:
#     input filename (full path)
#     Updates info hash to write the data into
#
sub ParseFile
{
   my($fname, $info) = @_;
   my($line);
   my($line_type);
   my($line_value);

   if (! -f $fname)
   {
        report_error_and_exit(BBP_RC_FILE_NOT_EXIST, "The specified $fname file does not exist or not readable.");
   }

   if (!open(INPUT, $fname))
   {
      print "\nUnable to open $fname for reading. $!\n";
      exit(1);
   }

   while ($line = <INPUT>)
   {
      chomp($line);

      $line =~ s/^#.*//;  # Strip comments
      $line =~ s/\s*$//; # Strip trailing spaces

      next if ($line =~ /^$/); # Skip blank lines

      if ($line =~ /^([^\s]+)\s+(.*)$/)
      {
         $line_type = $1;
         $line_value = $2;

         if (!exists($info->{$line_type}))
         {
            $info->{$line_type} = [];
         }
         push(@{$info->{$line_type}}, $line_value);
      }
      else
      {
         print "Unrecognized line, '$line', in $fname.\n";
         close INPUT;
         exit(1);
      }

   }
   close INPUT;
}


# 
# getOrigPkgDir
#
#     determines the target package directory 
#     to get the info in the definition.pkg and filelist.pkg files
#
# Parameters:
#     package name
#
sub getOrigPkgDir($$)
{
    my $stream = shift;
    my $pkgname = shift;
    my ( @pkgdirs, @compiledir);

    my $pi = new VpUtils::VpPackage;
    $pi->get_package_info($pkgname, $stream, \@pkgdirs, \@compiledir );

    if (scalar @pkgdirs == 0 )
    { 
        report_error_and_exit(BBP_RC_ERROR, "Failed to find package dir for $pkgname package.");
    }

    for my $pkgdir (@pkgdirs)
    {
        $pkgdir = "/view/$streamData{$stream}{BUILD_VIEW}/$pkgdir";

        report_error_and_exit(BBP_RC_ERROR, "$pkgname package directory $pkgdir does not exist.") 
            unless (-d $pkgdir);


       `grep -q "<pkg_name>$pkgname</pkg_name>" $pkgdir/definition.pkg 2>/dev/null`;
        if ($? != 0)
        {
            chomp(my $pkg = `grep -Po '<pkg_name>.*</pkg_name>' $pkgdir/definition.pkg | sed 's/<\\/*pkg_name>//g'`);
            printToLogFile("$pkgdir is not the correct package dir for $pkgname: $pkg");
            next;
        }
        # Found the pkgdir, return
        # We are only interested in the definition.pkg file from the target
        # package.
        return $pkgdir;
    }
 
    # This mean we haven't found any package directory matching $pkgname.
    report_error_and_exit(BBP_RC_ERROR, "Failed to find package dir for $pkgname package.");
}

sub createDefinitionPkg($$$$$$)
{
    my $stream  = shift;
    my $pkgname = shift;
    my $pkgdir  = shift;
    my $family  = shift;
    my $target  = shift;
    my $pkgver  = shift;

    my @code_sections;
    my @appliesto;

    my $targetName = ($target eq "*") ? "ALL" : $target;
    printToLogFile("Creating definition.pkg for $pkgname pkg for $family/$targetName.", DEBUG_LEVEL_1);

    # First compute and collect the fields that will be added to the
    # definiton.pkg file.
    # 1. Code sections in the following format:
    #    $csname; OBJID:$objectid; TIMESTAMP:$file_id
    #    objectid and file_id are taken from patch_info files returnes from vsePatchCreate
    for my $cs (@{$pkgs{$stream}{$pkgname}{$family}{$target}{'codesections'}})
    {
        my $objectid = $cs->{'objectid'};
        my $csname = $cs->{'csname'};
        my $file_id = $cs->{'file_id'}; 
        push @code_sections, "$csname; OBJ_ID:$objectid; TIMESTAMP:$file_id";
    }

    printToLogFile("Pkgs " . Dumper($pkgs{$stream}{$pkgname}), DEBUG_LEVEL_3);

    # get the definition.pkg as is
    my $targetDir = getOrigPkgDir($stream, $pkgname);
    `cp "$targetDir/definition.pkg" "$pkgdir/definition.pkg"`;
    `chmod +rw $pkgdir/definition.pkg`;

    my $fname = "$pkgdir/definition.pkg";
    open DEF_PKG, ">>$fname" or
        report_error_and_exit(BBP_RC_ERROR, "Could not write to $fname");

    # The applies_to field is set to the corresponding KNR parcel name
    # in real_wrapit script during "ubuild pkg".
    # We only pass the pkg version to make sure the KNR parcel name
    # matches the version of bintap.
    # Is it too paranoid to compare the versions?
    # When ubuild pkg is executed the PKG_VERSION is set to this value
    # anyway..
    print DEF_PKG "\n<applies_to>$pkgver</applies_to>\n";

    if (scalar @code_sections > 0 )
    {
        print DEF_PKG "<codesections>\n";
        for my $codesection (@code_sections)
        {
            print DEF_PKG "$codesection\n";
        }
      
        print DEF_PKG "</codesections>\n";
    }
    print DEF_PKG "<type>bintap_package</type>\n";
    close DEF_PKG;
}

sub createBuildmk($$$$)
{
    my $pkgname     = shift;
    my $pkgdir      = shift;
    my $family      = shift;
    my $target      = shift;

    my $targetName = ($target eq "*") ? "ALL" : $target;
    printToLogFile("Creating Build.mk for $pkgname pkg for $family/$targetName.", DEBUG_LEVEL_1);

    my $fname = "$pkgdir/Build.mk";
    open BUILDMKFILE, ">$fname" or
        report_error_and_exit(BBP_RC_ERROR, "Could not write to $fname");

    if ($target eq "*")
    {
        print BUILDMKFILE "PACKAGES := $pkgname\n";
    }
    else
    {
        print BUILDMKFILE "$target" . "_PACKAGES := $pkgname\n";
    }

    close BUILDMKFILE;
}


sub createFilelistPkg($$$$$)
{
    my $stream = shift;
    my $pkgname = shift;
    my $pkgdir = shift;
    my $family = shift;
    my $target = shift;

    my $line;
    my @filelist_lines;
    
    my $targetName = ($target eq "*") ? "ALL" : $target;
    printToLogFile("Creating filelist.pkg for $pkgname pkg for $family/$targetName.", DEBUG_LEVEL_1);

    for my $cs (@{$pkgs{$stream}{$pkgname}{$family}{$target}{'codesections'}})
    {
        my $objectid = $cs->{'objectid'};
        $objectid =~ s/#.*//;  #Strip the checksum
        my $csname = $cs->{'csname'};
        my $csDir = $cs->{'csDir'};

        my $objectid_dir = dirname($objectid);

        my $layer = determineLayer($pkgMapFile, \%pkgmap, $pkgname);

        # Exception for NCGLHA layer:
        # The install directories are enforced for VSE and app packages.
        # Hence, the actual installation paths are determined in the InstallMacro hash in pkgtoolHandlers.
        # This enforcement does not exist for NCGL.
        # The NCGL packages use install paths equivalent to their runtime path relative to root.
        # Then the rpm is changed to install in the appropriate location under /tftpboot.
        # So we have to pass the full installation path for the code section in the filelist.pkg
        if ($layer eq "NCGLHA")
        {
            my $installdir = "/bintaps$objectid_dir";
            $line = "F $family $targetName \"\$\{ncgl_root\}$installdir/$csname\" swadm swadm 644 \"$csDir/$csname\"";
        }
        else
        {
            # The defined path macro for applications are different than Siren
            if (defined $ENV{USE_APPNAMES})
            {
                my $APP_RELEASE = defined $ENV{APP_RELEASE} ? $ENV{APP_RELEASE}
                                                            : $ENV{ntmkbw_APP_RELEASE};
                report_error_and_exit(BBP_RC_INVALID_PARM, "ntmkbw_APP_RELEASE must be defined.")
                    if ($APP_RELEASE eq "");

                my %PkgRolesPecs = ();
                for my $role (keys %{$pkgmap{$pkgname}{$layer}{$family}{$target}})
                {
                    for my $pec (keys %{$pkgmap{$pkgname}{$layer}{$family}{$target}{$role}})
                    {
                        loadAppMacros($ENV{USE_APPNAMES}, $APP_RELEASE, $family, $target, $role, $pec);
                    }
                }
            }
            else
            {
                my $VSE_RELEASE = defined $ENV{VSE_RELEASE} ? $ENV{VSE_RELEASE}
                                                            : $ENV{ntmkbw_VSE_RELEASE};

                report_error_and_exit(BBP_RC_INVALID_PARM, "ntmkbw_VSE_RELEASE must be defined.")
                    if ($VSE_RELEASE eq "");

                my %PkgRolesPecs = ();
                for my $role (keys %{$pkgmap{$pkgname}{$layer}{$family}{$target}})
                {
                    for my $pec (keys %{$pkgmap{$pkgname}{$layer}{$family}{$target}{$role}})
                    {
                        loadCnpMacros($VSE_RELEASE, $family, $target, $role, $pec, $pkgname);
                    }
                }
            }

            my $runtime_path = $objectid_dir;
            printToLogFile("Path Macros " . Dumper(\%PathMacros), DEBUG_LEVEL_3);
            my $path_macro = translateRuntimePathToInstallMacro(\$runtime_path, $family, $ENV{USE_APPNAMES});
            report_error_and_exit(BBP_RC_ERROR, "Failed to convert runtime path to Install macro. Runtime path: $runtime_path")
                if (!$path_macro);
            printToLogFile("Derived Path macro for $runtime_path runtime path: $path_macro.", DEBUG_LEVEL_1);

            # translateRuntimePathToInstallMacro will return the best
            # match for us. Sometimes the final runtime path has more
            # components in it. For instance if the following is the entry
            # Example: If the following was entered in the filelist.pkg
            # file of the target bin/lib as the install path:
            # ${current_arch_ca_bin}/ee/dolly"
            # The install path macro will not be sufficient.
            # So, find out if there is any extra paths in the object:
            if ($objectid_dir =~ /^$runtime_path(.*)$/)
            {
                my $extra_path = $1;
                printToLogFile("Calculated extra path is $extra_path.", DEBUG_LEVEL_1);
                $line = "F $family $targetName \"\$\{$path_macro\}$extra_path/$csname\" swadm swadm 644 \"$csDir/$csname\"";
            }
        }
        printToLogFile("Adding \"$line\" to $pkgdir/filelist.pkg.", DEBUG_LEVEL_1);
        push @filelist_lines, $line;
    }

    if (scalar @filelist_lines == 0)
    {
        report_error_and_exit(BBP_RC_ERROR, "Failed to generate filelist.pkg file for $pkgname, $family/$targetName");
    }

    open FILE_PKG, ">$pkgdir/filelist.pkg" or
          report_error_and_exit(BBP_RC_ERROR, "Could not write to $pkgdir/filelist.pkg");
    for my $l (@filelist_lines)
    {
        print FILE_PKG "$l\n";
    }

    close FILE_PKG;
}

# Gets $stream, pkgname, build version as input,
# + Determines affected product components(ncls) for the specified pkg
# + Determines the final package name from pkgmap structure
# + Updates the global pkgs hash with the finalname info
sub processPkgMapData($$)
{
    my $stream = shift;
    my $pkgname = shift;

    if (scalar keys %pkgmap == 0)
    {
        report_error_and_exit(BBP_RC_ERROR, "Package map is empty.");
    }
    my $layer = determineLayer($pkgMapFile, \%pkgmap, $pkgname);

    my %familyList;
    my %targetList;
    for my $family (keys %{$pkgmap{$pkgname}{$layer}})
    {
        for my $target (keys %{$pkgmap{$pkgname}{$layer}{$family}})
        {
            for my $role (keys %{$pkgmap{$pkgname}{$layer}{$family}{$target}})
            {
                for my $pec (keys %{$pkgmap{$pkgname}{$layer}{$family}{$target}{$role}})
                {

                    my $ncl = selectNcl(\%pkgmap,
                                        \%nclmap,
                                        $pkgname,
                                        $layer,
                                        $family,
                                        $target,
                                        $role,
                                        $pec);
                    next if (!defined $ncl);

                    $productComponents{$ncl}++; # For use in generating admindata

                    my $name = $pkgmap{$pkgname}{$layer}{$family}{$target}{$role}{$pec}{'NAME'};

                    # We are only interested in the finalname for the
                    # supported architectures.
                    # Supported architectures are defined in PACS database and
                    # returned to us by the code section creation tool.  
                    if (exists $pkgs{$stream}{$pkgname}{$family}{$target})
                    {
                        printToLogFile("Finalname for $pkgname.$family.$target.$role.$pec is $name", DEBUG_LEVEL_2);
                        push @{$pkgs{$stream}{$pkgname}{$family}{$target}{'finalname'}}, $name;
                    }
                }
            }
        }
    }
}

#
# generatePatchAdmindata:
# 
#     Generates the admindata xml file with the information in the global
#     %admindata hash.
#
# Parameters:
#     pkg directory to create the admindata in       
sub generatePatchAdmindata($)
{
    my $to_pkgdir = shift;

    my $fname = "$to_pkgdir/admindata";
    open ADMIN, ">$fname" or
        report_error_and_exit(BBP_RC_ERROR, "Could not write to $fname");

    my %data = %admindata;

    my $now = `date +"%Y-%m-%d %H:%M:%S"`;
    chomp $now;

    
    print ADMIN <<ENDOFADMINHEADER;
<admindata>
    <metaversion>1.1</metaversion>
    <payload>
        <patch_id>$data{'PATCH_ID'}</patch_id>
        <title>$data{'TITLE'}</title>
        <description>$data{'DESCRIPTION'}</description>
        <created>$now</created>
        <baseline_release>$ENV{'ntmkbw_VSE_RELEASE'}</baseline_release>
        <type>$patch_type</type>
ENDOFADMINHEADER

    # Delete the admindata tags we've manually inserted.
    delete $data{'PATCH_ID'};
    delete $data{'TITLE'};
    delete $data{'DESCRIPTION'};

    # Delete the following ones as well, just in case, although they shouldn't
    # exist in the input admindata anyway.
    delete $data{'CREATED'};
    delete $data{'BASELINE_RELEASE'};
    delete $data{'TYPE'};

    #
    # Add the list of required patches to the admindata
    # GB - I don't know how I am going to determine ncl map of these patches
    if (defined $data{'REQUIRES'})
    {
        for my $req (split /\s+/, $data{'REQUIRES'})
        {
            $requiredPatches{$req}++ if ($req ne "");
        }
   } 

   delete $data{'REQUIRES'};

   if (scalar keys %requiredPatches > 0)
   {
      print ADMIN "       <requires>\n";
      for my $req (sort keys %requiredPatches)
      {
         print ADMIN "       $req\n";
      }
      print ADMIN "       </requires>\n";
   }

    # Print product component requires list to the admindata
    printProductComponentRequiresList(\*ADMIN, \%nclPatchMap);

    #
    # Add the list of product components to the admindata
    #
    print ADMIN "<product_components>\n";
    for my $c (sort keys %productComponents)
    {
        print ADMIN "$c\n";
    }
    print ADMIN "</product_components>\n";

    #
    # Add all the other tags that were in the input admindata
    #
    for my $K (sort keys %data)
    {
        my $k = lc($K);

        print ADMIN "        <$k>$data{$K}</$k>\n";
    }

    print ADMIN <<ENDADMINDATA;
    </payload>
</admindata>
ENDADMINDATA

    close ADMIN;
}

# 
# validateXmlFile
#
sub validateXmlFile($)
{
   my $file = shift;

   # The patch xml file is common for all streams,
   # validate it just once.
   if (!$xml_validated)
   {
      report_error_and_exit(BBP_RC_ERROR, "Unable to read schema file: $vsepatchSchema")
          if (! -r $vsepatchSchema);
      
      #
      # Validate the XML
      #
      my $xmlValidation = `$xmlValidator $file $vsepatchSchema 2>&1`;
      if ($? != 0)
      {
          print STDERR $xmlValidation, "\n";
          report_error_and_exit(BBP_RC_ERROR, "Patch XML validation failed. Aborting...");
      }
      $xml_validated = 1; 
   }
}

#
# setProgressFlag:
#
#    Set the specified progress flag
#
sub setProgressFlag($$$)
{
    my $pkgname  = shift;
    my $pkgver   = shift;
    my $progress = shift;

    my $dir = $logdir;

    my $flagPrefix = $dir . "/" . $pkgname . "_" . $pkgver . "_";
    my $flag       = "$flagPrefix$progress";

    `rm $flagPrefix* 2>/dev/null ; touch $flag`;

    $lastProgressFlagPrefix = $flagPrefix;
}


# 
# validateAdmindata
#
sub validateAdmindata($)
{
    my $admin = shift;

    if (defined $admin->{'TYPE'})
    {
        if ($admin->{'TYPE'} ne $patch_type)
        {
            report_error_and_exit(BBP_RC_ERROR, "Patch type in $xmlfile is incorrect.");
        }
    }

    if (defined $admin->{'REBOOT_REQUIRED'})
    {
       if ($admin->{'REBOOT_REQUIRED'} ne 'N')
       {
          report_error_and_exit(BBP_RC_ERROR, 
                                "REBOOT_REQUIRED field cannot be $admin->{'REBOOT_REQUIRED'} for $patch_type patches.");
       }
    }
}

#TODO: Clone of the parseAdmindata of buildpatch. move to pkgutils
# parseAdmindata:
#
#    Parse the ADMINDATA element from the parsed XML
#
sub parseAdmindata($)
{
    my $data = shift;
    #
    # The ADMINDATA node is structured with child element nodes, which in turn
    # contain child nodes themselves. We're interested in the "grandchild"
    # text nodes, as these would be the values we're looking for.
    #
    # For example, in the following XML snippet:
    #    <ADMINDATA>
    #       <PATCH_ID>dpenney.1</PATCH_ID>
    #    </ADMINDATA>
    #
    # <ADMINDATA> is the node passed into this subroutine.
    # <PATCH_ID> is the first child ELEMENT_NODE we see, and its
    # child TEXT_NODE has the value "dpenney.1"
    #
    for my $node ($data->getChildNodes)
    {
        if (($node->getNodeType == ELEMENT_NODE) && ($node->hasChildNodes))
        {
            for my $child ($node->getChildNodes)
            {
                if ($child->getNodeType == TEXT_NODE)
                {
                    $admindata{$node->getNodeName} = $child->getNodeValue;
                }
            }
        }
    }
}


sub createStreamPackageDirs($)
{
    my $stream = shift;

    for my $pkgname (sort keys %{$pkgs{$stream}})
    {
        # See if the package is included in the packageMapping.list file
        # Determine the source layer
        my @layers = keys %{$pkgmap{$pkgname}};
        if (scalar @layers == 0)
        {
            print "$pkgname is not included in the $pkgMapFile. Skipping..\n";
            delete $pkgs{$stream}{$pkgname};
            next;
        }

        # pkgs hash is filled in generateStreamCodeSections
        # 1. Determine the package version for each package.
        #    Each Bintap parcel must apply to a K&R parcel
        #    This can be either the .0 version from the load or a K&R patch.
        #    We will build the bintap parcels with the package versions of these K&R parcels. 
        #    So, let's fill the global pkg_version hash first:
        $pkg_version{$pkgname} = determineKNRVersion(\%builtKR, $pkgname, $streamData{$stream}{BUILD_VERSION}); 
        printToLogFile("Package version for $pkgname is set to $pkg_version{$pkgname}", DEBUG_LEVEL_2); 
        # 2. Loop through the pkgmap:
        #    + Derive the final package name for both appliesto K&R and Bintap
        #    + Derive the effected product components
        processPkgMapData($stream, $pkgname);

        for my $family (sort keys %{$pkgs{$stream}{$pkgname}})
        {
            for my $target (sort keys %{$pkgs{$stream}{$pkgname}{$family}})
            {
                my $targetName = ($target eq "*") ? "fam" : $target;
                printToLogFile("Creating Package dir for $pkgname pkg for $family/$targetName", DEBUG_LEVEL_2);
                my $pkgdir = "$streamData{$stream}{LOADBUILD_OBJECT_DIR}/$pkgname/$family" . "_" . $targetName;
                $pkgs{$stream}{$pkgname}{$family}{$target}{'pkgdir'} = $pkgdir;
                $pkgs{$stream}{$pkgname}{$family}{$target}{'pkgname'} = $pkgname;
                createPackageDir( $stream, 
                                  $pkgname, 
                                  $pkgdir, 
                                  $family, 
                                  $target, 
                                  $pkg_version{$pkgname});
            }
        }
    }
}


sub createPackageDir($$$$$$)
{
    my $stream  = shift;
    my $pkgname = shift;
    my $pkgdir  = shift;
    my $family  = shift;
    my $target  = shift;
    my $pkgver  = shift;

    rmdir($pkgdir) if (-d $pkgdir);
    mkpath("$pkgdir") unless (-d "$pkgdir");

    createDefinitionPkg($stream, $pkgname, $pkgdir, $family, $target, $pkgver);
    createBuildmk($pkgname, $pkgdir, $family, $target);
    createFilelistPkg($stream, $pkgname, $pkgdir, $family, $target);

}


sub runCurrentViewBuild($$$$)
{
    my $stream = shift;
    my $pkgref = shift;
    my $pkgname = shift;
    my $pkgver = shift;

    my ($family, $target, %logfiles);

    announce "Building $pkgname, version $pkgver.\n";

    # Create logs for the archs
    for $family (sort keys %{$pkgref})
    {
        for $target (sort keys %{$pkgref->{$family}})
        {
            my $targetName = ($target eq "*") ? "fam" : $target;
            my $logFilename = $logdir . "/" . $pkgname . "_" . $family . "_" . $targetName . "_" . $pkgver . ".txt";
            $buildLogFiles{$pkgname}{$family}{$target} = $logFilename;
            open $logfiles{$family}{$target}, ">$logFilename"
                or report_error_and_exit(BBP_RC_ERROR, "Unable to create log file: $logFilename");

            autoflush { $logfiles{$family}{$target} };
        } 
    }

    # Do the clean and mk first
    announce "  Cleaning.\n";
    for $family (sort keys %{$pkgref})
    {
        for $target (sort keys %{$pkgref->{$family}})
        {
            cleanCurrentViewPackage($logfiles{$family}{$target},
                                    $stream,
                                    $pkgref,
                                    $family,
                                    $target);
        }
    }

    if (waitForThreads() > 0)
    {
        report_error_and_exit(BBP_RC_ERROR, "Failed to clean. Aborting...");
    }

    my $buildopt = (defined $ENV{BUILDBINTAP_LOADBUILD_D}) ? "-D " : " -l $streamData{$stream}{FINAL_COMPILE_DIR}";
    my $setupCmd  = $streamData{$stream}{BUILD_SETUP};

    # Now run the mk. We only need to run this for one arch.
    for $family (sort keys %{$pkgref})
    {
        for $target (sort keys %{$pkgref->{$family}})
        {
            my $pkgdir = $pkgref->{$family}{$target}{'pkgdir'};
            my $targetName = ($target eq "*") ? "fam" : $target;
 
            my $cmd = "$setupCmd && cd $pkgdir && $ubuild $buildopt mk";
            announce "  Setting up mk for $family.$target.\n";
            runCmd($logfiles{$family}{$target},
                   "ubuild mk",
                   "build mk of $pkgname failed. Aborting...\n",
                   "$cmd");
            my $rc = $?;
            if ($rc != 0)
            {
                print "Please review the ubuild logs at:\n";
                print "$buildLogFiles{$pkgname}{$family}{$target}\n";
                return ($rc) if (threads->tid() != 0);
                exit ($rc);
            }
        }
    }

    for $family (sort keys %{$pkgref})
    {
        for $target (sort keys %{$pkgref->{$family}})
        {
            buildCurrentViewPackage($logfiles{$family}{$target},
                                    $stream, 
                                    $pkgref, 
                                    $family, 
                                    $target); 
        }
    }

    if (waitForThreads() > 0)
    {
        report_error_and_exit(BBP_RC_ERROR, "Failed to build package $pkgname. Aborting...");
    }

    my $dir = "$streamData{$stream}{LOADBUILD_OBJECT_DIR}/$ENV{'patch_TARGOBJDIR_PATTERN'}/pkgs";
    validateBuiltParcels($pkgref, $pkgname, $pkgver, $dir, \%logfiles);
}

sub closeLogsFT($)
{
    my $logsref = shift;
    my %logs = %{$logsref};
    for my $family (keys %logs)
    {
        for my $target (keys %{$logs{$family}})
        {
            close $logs{$family}{$target};
        }
    }
}


sub runOtherViewBuild($$$$)
{
    my $stream = shift;
    my $pkgref = shift;
    my $pkgname = shift;
    my $pkgver = shift;

    my $family;
    my $target;

    announce "Building $pkgname, version $pkgver.\n";
    my %logfiles = ();
    # Create logs for the archs
    for $family (sort keys %{$pkgref})
    {
        for $target (sort keys %{$pkgref->{$family}})
        {
            my $targetName = ($target eq "*") ? "fam" : $target;
            my $logFilename = $logdir . "/" . $pkgname . "_" . $family . "_" . $targetName . "_" . $pkgver . ".txt";
            $buildLogFiles{$pkgname}{$family}{$target} = $logFilename;
            open $logfiles{$family}{$target}, ">$logFilename"
                or report_error_and_exit(BBP_RC_ERROR, "Unable to create log file: $logFilename");

            autoflush { $logfiles{$family}{$target} };
        }
    }

    # Do the clean and mk first
    announce "  Cleaning.\n";
    for $family (sort keys %{$pkgref})
    {
        for $target (sort keys %{$pkgref->{$family}})
        {
            cleanOtherViewPackage($logfiles{$family}{$target},
                                  $stream,
                                  $pkgref,
                                  $family,
                                  $target);
        }
    }

    if (waitForThreads() > 0)
    {
        report_error_and_exit(BBP_RC_ERROR, "Failed to clean. Aborting...");
    }

    my $buildopt = (defined $ENV{BUILDBINTAP_LOADBUILD_D}) ? "-D " : " -l $streamData{$stream}{FINAL_COMPILE_DIR}";
    my $setupCmd  = $streamData{$stream}{BUILD_SETUP};
    my $build_view = $streamData{$stream}{BUILD_VIEW};

    # Now run the mk. We only need to run this for one arch.
    for $family (sort keys %{$pkgref})
    {
        for $target (sort keys %{$pkgref->{$family}})
        {
            my $pkgdir = $pkgref->{$family}{$target}{'pkgdir'};
            my $targetName = ($target eq "*") ? "fam" : $target;

            my $cmd = "$setupCmd && cd $pkgdir && $ubuild $buildopt mk";
            announce "  Setting up mk for $family.$target.\n";
            runCmdInView(
                     $build_view,
                     $logfiles{$family}{$target},
                     "ubuild mk",
                     "Build mk of NCGLHA $pkgname failed for $family/$targetName. Aborting...\n",
                     "$cmd 2>&1");
            my $rc = $?;
            if ($rc != 0)
            {
                print "Please review the ubuild logs at:\n";
                print "$buildLogFiles{$pkgname}{$family}{$target}\n\n";
                return ($rc) if (threads->tid() != 0);
                exit ($rc);
            }
        }
    }

    for $family (sort keys %{$pkgref})
    {
        for $target (sort keys %{$pkgref->{$family}})
        {
            buildOtherViewPackage($logfiles{$family}{$target},
                                  $stream,
                                  $pkgref,
                                  $family,
                                  $target);
        }
    }

    if (waitForThreads() > 0)
    {
        report_error_and_exit(BBP_RC_ERROR, "Failed to build package $pkgname. Aborting...");
    }

    validateBuiltParcels($pkgref, $pkgname, $pkgver, $tmpdir, \%logfiles);
}


sub validateBuiltParcels($$$$$)
{
    my $pkgref  = shift;
    my $pkgname = shift;
    my $pkgver  = shift;
    my $dir     = shift;
    my $logfiles = shift;

    for my $family (sort keys %{$pkgref})
    {
        for my $target (sort keys %{$pkgref->{$family}})
        {
            my $targetName = ($target eq "*") ? "fam" : $target;
            my $targobjdir = $dir;
            # For ncgl build, the build output is put to a temp directory
            # For other builds, the output is in the family and target directories. 
            # The $dir passed to this proc is in the following format:
            # OBJPATH/_::target::_ncgl_15.0_::family::"/pkgs
            # Replacing ::target:: and ::family:: keywords with the real values.
            $targobjdir =~ s/::family::/$family/g;
            $targobjdir =~ s/::target::/$targetName/g;
            for my $finalname (sort @{$pkgref->{$family}{$target}{'finalname'}})
            {
                # The finalname derived from the pkgmap is common for both
                # KNR and bintaps
                # For BINTAPS, TAP_<unique number> is used for versioning the parcels
                # So we have to append TAP_<id> extention to the finalname
                # here.
                $finalname .= $ENV{'USE_BINTAP_NAME'};
                printToLogFile("Final name: $finalname", DEBUG_LEVEL_2);
                my $pattern = sprintf "%s/%s-%s-*.parcel",
                                      $targobjdir,
                                      $finalname,
                                      $pkgver;
                my @pfile = glob($pattern);

                if (! -f $pfile[0])
                {
                    setProgressFlag($pkgname, $pkgver, FLAG_FAILED);
                    closeLogsFT($logfiles);
                    report_error_and_exit(BBP_RC_ERROR, 
                        "Unable to find $finalname parcel file for $family/$target of $pkgname in $dir");
                }
                printToLogFile("Found the parcel: $pfile[0]", DEBUG_LEVEL_2);
                push @parcels, $pfile[0];
            }
        }
    }
    setProgressFlag($pkgname, $pkgver, FLAG_COMPLETED);
    closeLogsFT($logfiles);
}

#build one parcel 
sub buildOtherViewPackage($$$$)
{
    my $logFH = shift;
    my $stream = shift;
    my $pkgref = shift;
    my $family = shift;;
    my $target = shift;

    my $build_view = $streamData{$stream}{BUILD_VIEW};
    my $setupCmd  = $streamData{$stream}{BUILD_SETUP}; 
       $setupCmd .= ";export USE_PKGMAPFILE=$pkgMapFile";
    my $pkgdir = $pkgref->{$family}{$target}{'pkgdir'};
    my $pkgname = $pkgref->{$family}{$target}{'pkgname'};
    my $pkgver = $pkg_version{$pkgname}; 
    my $targetName = ($target eq "*") ? "fam" : $target;
    my $buildopt = (defined $ENV{BUILDBINTAP_LOADBUILD_D}) ? "-D " : " -l $streamData{$stream}{FINAL_COMPILE_DIR}";
    my $objpath = $streamData{$stream}{LOADBUILD_OBJECT_DIR};

    printToLogFile("In buildOtherViewPackage", DEBUG_LEVEL_2);
    my $buildcmd;

    if ($target eq "*")
    {
        $buildcmd = "$ubuild $buildopt -f $family PKG_VERSION=$pkgver";
    }
    else
    {
        $buildcmd = "$ubuild $buildopt -t $target PKG_VERSION=$pkgver";
    }

    async
    {
        my $cmd = "$setupCmd && cd $pkgdir && $buildcmd pkg";
        announce "  Building $family/$targetName for $pkgname.\n";
        runCmdInView(
                 $build_view,
                 $logFH,
                 "ubuild pkg",
                 "Build of NCGLHA pkg $pkgname failed to generate the parcel for $family/$targetName. Aborting...\n",
                 "$cmd 2>&1");
        my $rc = $?;
        if ($rc != 0)
        {
            print "Please review the ubuild logs at:\n";
            print "$buildLogFiles{$pkgname}{$family}{$target}\n\n";
            return ($rc) if (threads->tid() != 0);
            exit ($rc);
        }

        # Now to run mungeEm to build the parcel.
        my $targobjdir = $ENV{'patch_NCGLHA_TARGOBJDIR_PATTERN'};
        $targobjdir =~ s/::target::/$targetName/g;
        $targobjdir =~ s/::family::/$family/g;

        my $pkgSuffix = $family;
        $pkgSuffix .= "_$target" if ($target ne "*");

        my $ncglpkg = $pkgname . "_" . $pkgSuffix . "$ENV{'USE_BINTAP_NAME'}" . "-" . $pkgver . "-1.i386.rpm";
        my $rpmfile = "$objpath/$targobjdir/pkgs/$ncglpkg";

        # In a thread, changes to the environment are not passed to
        # system() calls, so we need to set it in the command itself.
        my $envCmd = "export VSE_RELEASE=$ENV{ntmkbw_VSE_RELEASE}";
        $envCmd .= ";export PKG_VERSION=$pkgver";
        $envCmd .= ";export PRODUCTID=Siren";
        $envCmd .= ";export PROD_RELEASE=$ENV{ntmkbw_VSE_RELEASE}";
        $envCmd .= ";export USE_SRC_ROOT=\"\"";
        $envCmd .= ";export USE_PKGMAPFILE=$pkgMapFile";
        $envCmd .= ";export USE_BINTAP_NAME=$ENV{'USE_BINTAP_NAME'}";
        $envCmd .= ";export USE_BINTAP=/bintaps";
        # We have the applies-to data in the definition.pkg file
        # So we have to pass the definition.pkg file as metadata file.
        runCmd($logFH,
                 "mungeEm",
                 "Build of NCGLHA pkg $pkgname failed to munge for $family/$targetName. Aborting...\n",
                 "$envCmd;$mungeEm -a $family -t $targetName -f $rpmfile -o $tmpdir -m $pkgdir/definition.pkg 2>&1");
        $rc = $?;
        if ($rc != 0)
        {
            print "Please review the ubuild logs at:\n";
            print "$buildLogFiles{$pkgname}{$family}{$target}\n\n";
            return ($rc) if (threads->tid() != 0);
            exit ($rc);
        }
    };
}


sub buildCurrentViewPackage($$$$$$)
{
    my $logFH = shift;
    my $stream = shift;
    my $pkgref = shift;
    my $family = shift;;
    my $target = shift;

    my $build_view = $streamData{$stream}{BUILD_VIEW};
    my $setupCmd = $streamData{$stream}{BUILD_SETUP};
       $setupCmd .= ";export USE_PKGMAPFILE=$pkgMapFile";
    my $pkgdir  = $pkgref->{$family}{$target}{'pkgdir'};
    my $pkgname = $pkgref->{$family}{$target}{'pkgname'};
    my $pkgver  = $pkg_version{$pkgname};
    my $targetName = ($target eq "*") ? "fam" : $target;
    my $buildopt = (defined $ENV{BUILDBINTAP_LOADBUILD_D}) ? "-D " : " -l $streamData{$stream}{FINAL_COMPILE_DIR}";

    my $buildcmd;

    if ($target eq "*")
    {
        $buildcmd = "$ubuild $buildopt -f $family PKG_VERSION=$pkgver";
    }
    else
    {
        $buildcmd = "$ubuild $buildopt -t $target PKG_VERSION=$pkgver";
    }

    async
    {
        my $cmd = "$setupCmd && cd $pkgdir && $buildcmd pkg";
        announce "  Building $family/$targetName for $pkgname.\n";
        runCmd($logFH,
               "ubuild pkg",
               "Build of $pkgname failed to generate the parcel for $family/$targetName. Aborting...\n",
               "$cmd");
        my $rc = $?;
        if ($rc != 0)
        {
            print "Please review the ubuild logs at:\n";
            print "$buildLogFiles{$pkgname}{$family}{$target}\n\n";
            return ($rc) if (threads->tid() != 0);
            exit ($rc);
        }
    };

}


sub cleanCurrentViewPackage($$$$$)
{
    my $logFH = shift;
    my $stream = shift;
    my $pkgref = shift;
    my $family = shift;;
    my $target = shift;

    my $pkgver = "$streamData{$stream}{BUILD_VERSION}.0";
    my $setupCmd = $streamData{$stream}{BUILD_SETUP};
    my $pkgdir = $pkgref->{$family}{$target}{'pkgdir'};
    my $pkgname = $pkgref->{$family}{$target}{'pkgname'};
    my $targetName = ($target eq "*") ? "fam" : $target;
    my $buildopt = "-l $streamData{$stream}{FINAL_COMPILE_DIR}";

    my $buildcmd;
    if ($target eq "*")
    {
        $buildcmd = "$ubuild $buildopt -f $family PKG_VERSION=$pkgver";
    }
    else
    {
        $buildcmd = "$ubuild $buildopt -t $target PKG_VERSION=$pkgver";
    }

    async
    {
        my $cmd = "$setupCmd && cd $pkgdir && $buildcmd clean";
        # First do a clean
        runCmd($logFH,
                 "ubuild clean",
                 "build clean of $pkgname failed for $family/$targetName. Aborting...\n",
                 "$cmd");
        my $rc = $?;
        if ($rc != 0)
        {
            print "Please review the ubuild logs at:\n";
            print "$buildLogFiles{$pkgname}{$family}{$target}\n\n";
            return ($rc) if (threads->tid() != 0);
            exit ($rc);
        }
    };
}

sub cleanOtherViewPackage($$$$)
{
    my $logFH = shift;
    my $stream = shift;
    my $pkgref = shift;
    my $family = shift;;
    my $target = shift;

    my $setupCmd = $streamData{$stream}{BUILD_SETUP};
    my $pkgdir  = $pkgref->{$family}{$target}{'pkgdir'};
    my $pkgname = $pkgref->{$family}{$target}{'pkgname'};
    my $pkgver  = $pkg_version{$pkgname};
    my $targetName = ($target eq "*") ? "fam" : $target;
    my $buildopt = "-l $streamData{$stream}{FINAL_COMPILE_DIR}";
    my $build_view = $streamData{$stream}{BUILD_VIEW};

    my $buildcmd;
    if ($target eq "*")
    {
        $buildcmd = "$ubuild $buildopt -f $family PKG_VERSION=$pkgver";
    }
    else
    {
        $buildcmd = "$ubuild $buildopt -t $target PKG_VERSION=$pkgver";
    }
    my $cmd = "$setupCmd && cd $pkgdir && $buildcmd clean";
    async
    {
        # First do a clean
        runCmdInView(
                 $build_view,
                 $logFH,
                 "ubuild clean",
                 "Build clean of NCGLHA pkg $pkgname failed for $family/$targetName. Aborting...\n",
                 "$cmd 2>&1");
        my $rc = $?;
        if ($rc != 0)
        {
            print "Please review the ubuild logs at:\n";
            print "$buildLogFiles{$pkgname}{$family}{$target}\n\n";
            return ($rc) if (threads->tid() != 0);
            exit ($rc);
        }
    };
}


sub validateBuildControlFile($)
{
    my $control_file = shift;
    my %control_info = ();

    ParseFile($control_file, \%control_info);

    if (! defined ($control_info{'patch_id'}))
    {
        report_error_and_exit(BBP_RC_INVALID_PARM, "$control_file file\ndoes not contain patch_id information."); 
    }

    printToLogFile("Patch id: $control_info{'patch_id'}[0]", DEBUG_LEVEL_2);
    my $patch = $control_info{'patch_id'}[0];
    if ($patch ne $patchid)
    {
        report_error_and_exit(BBP_RC_INVALID_PARM, 
            "PATCH_ID info in the $bintapControlFile and $control_file do not match.");
    } 

    if (! defined ($control_info{'product_arch'}))
    {
        report_error_and_exit(BBP_RC_INVALID_PARM, "$control_file file\ndoes not contain product_arch information."); 
    }
}

sub showDebugParams()
{
    if (defined $ENV{PATCH_ENVIRONMENT} ||
        defined $ENV{NO_IGNORE_PATCHES} ||
        defined $ENV{DEBUG_LEVEL} ||
        defined $ENV{NOCLEANUP} ||
        defined $ENV{BUILD_TYPE} ||
        defined $ENV{SKIP_CODE_SECTIONS})
    {
        print "########################################\n";
        print "User Defined Environment variables:\n";
        print "########################################\n";
        print "    PATCH_ENVIRONMENT        : $ENV{PATCH_ENVIRONMENT}\n"
            if (defined $ENV{PATCH_ENVIRONMENT});
        print "    NO_IGNORE_PATCHES        : $ENV{NO_IGNORE_PATCHES}\n"
            if (defined $ENV{NO_IGNORE_PATCHES});
        print "    DEBUG_LEVEL              : $ENV{DEBUG_LEVEL}\n"
            if (defined $ENV{DEBUG_LEVEL});
        print "    BUILD_TYPE               : $ENV{BUILD_TYPE}\n"
            if (defined $ENV{BUILD_TYPE});
        print "    NOCLEANUP                : $ENV{NOCLEANUP}\n"
            if (defined $ENV{NOCLEANUP});
        print "    SKIP_CODE_SECTIONS       : $ENV{SKIP_CODE_SECTIONS}\n"
            if (defined $ENV{SKIP_CODE_SECTIONS});
        print "#########################################\n\n";
    }
}


sub validateRequiredEnvVars($)
{
    my $reqEnvVars = shift;

    # Test for required environment variables
    my @missingVars;
    
    for my $v (@{$reqEnvVars})
    {
        if (! $ENV{$v})
        {
            push (@missingVars, $v);
        }
    }

    if (scalar @missingVars != 0)
    {
        print STDERR "\nThe following required environment variables have not been set:\n";
        for my $v (@missingVars)
        {
            print STDERR "\t$v\n";
        }
        exit BBP_RC_ERROR;
    }

}

# 
# generatePatchDataFile
#
# Generate the data tar file for this patch 
# This file will be utilized when building patch on patches.
# The data file will contain:
#      + The CPPAT build control file,
#      + The CPPAT info files associated with the patch, 
#      + All of the code sections produced by the CPPAT toolset,
#      + All of the shadow code sections produced by the CPPAT toolset,
#      + A file that is composed of name/value pairs for:
#     	    + new procedure registrations
#     	    + new variable registrations,
#     	    + new constants registrations,
sub generatePatchDataFile($$$)
{
    my $data_file = shift;
    my $dir       = shift;
    my $patchInfo = shift;

    my $cmd;
    my $rc;

    printToLogFile("Generating Patch Data File: $data_file for files in $dir");
    # Remove the $data_file if it exists
    system("rm -f $data_file");

    # We want to keep the vsePatchCreate output dir format:
    # Put the code sections, pif, shadow and control files under
    # $stream folder so that it is seperated by stream when we extract it.
    for my $stream (keys %{$patchInfo})
    {
        report_error_and_exit(BBP_RC_ERROR, "Failed to append control_file to $data_file. No control_file found for $stream stream.")
            if (!$patchInfo->{$stream}{'control_file'});

        report_error_and_exit(BBP_RC_ERROR, "Failed to append spec file to $data_file. No spec file found for $stream stream.")
            if (!$patchInfo->{$stream}{'spec_file'});

        my ($control_file, $spec_file);
        chomp($control_file = `basename $patchInfo->{$stream}{'control_file'}`);
        chomp($spec_file = `basename $patchInfo->{$stream}{'spec_file'}`);
        $cmd = "tar rf $data_file -C $dir $stream/$control_file $stream/$spec_file";
        $rc = system($cmd);
        if ($rc != 0)
        {
            print "Failed to append $patchInfo->{$stream}{'control_file'} to $data_file.\n";
            print "Command failed: $cmd.\n";
            exit(1);
        }

        my $pif_list = "";
        for my $info (@{$patchInfo->{$stream}{'pifs'}})
        {
            # Must have cs and pif
            report_error_and_exit(BBP_RC_ERROR, 
                           "Failed to append pif info to $data_file. No code sections found for $stream stream.")
                if (!$info->{'cs'});

            report_error_and_exit(BBP_RC_ERROR, 
                          "Failed to append pif info to $data_file. No patch_info file found for $stream stream.")
                if (!$info->{'pif'});

            $pif_list .= " $stream/$info->{'cs'}";
            $pif_list .= " $stream/$info->{'pif'} ";
            $pif_list .= " $stream/$info->{'shadow'} " if ($info->{'shadow'});
        }

        $cmd = "tar rf $data_file -C $dir $pif_list";
        system($cmd);
        exit_if_failure("Failed to append $pif_list to $data_file.\n" . 
                        "Command failed: $cmd.");

        # If this is designer build(BUILD_TYPE_DESIGN), we also want to store the source files in
        # the .data file.
        # This is required for having the patch dependencies correctly when
        # building patches on patches.
        # For Vsepatch and Ebuild builds (BUILD_TYPE_VSEPATCH and
        # BUILD_TYPE_EBUILD), this is not required because the updated files
        # will be delivered to the stream, hence it will be included in the
        # patch view.
        if ($buildType eq BUILD_TYPE_DESIGN)
        {
            printToLogFile("This is a BUILD_TYPE_DESIGN build, will add source files as well.");

            # First, find out the update files from the control file
            $cmd = "grep update_file $dir/$stream/$control_file | cut -d ' ' -f2";
            my @update_files = split '\n', `$cmd`;
            chomp(@update_files);
            report_error_and_exit(BBP_RC_ERROR, "$control_file must contain \'update_file\' field.")
                if (scalar @update_files == 0);

            # Then get the new view name from the control file.
            chomp(my $new_view = `grep new_view $dir/$stream/$control_file | cut -d ' ' -f2`);
            for my $file (@update_files)
            {
                # Grab the update file from new view
                $file = "/view/$new_view$file";
                printToLogFile("Appending $file to data file.");
                my $tmp_dir = dirname($file);
                my $tmp_file = `basename $file`;
                $cmd = "tar rf $data_file -C $tmp_dir $tmp_file";
                $rc = system($cmd);
                if ($rc != 0)
                {
                    print "Failed to append $file to the $data_file.\n";
                    print "Command failed: $cmd.\n";
                    exit(1);
                }
            }
        }
    }
}

sub displayInputParamsToScreen()
{

    my $update_version_file_str = ($updateVersionFile)
                                ? "On"
                                : "Off";

    my $nocleanup_str = ($nocleanup)
                      ? "On"
                      : "Off";

    my $trace_str = ($trace)
                  ? "On"
                  : "Off";

    print <<ENDOFPRINT;
##################################################################################
    Patch XML file       : $xmlfile
    Bintap Control File  : $bintapControlFile
    Update Version File  : $update_version_file_str
    Build Type           : $buildType
    Output Dir           : $outdir
    Log Dir              : $logdir
    Patch Dir            : $patchdir
    Nocleanup            : $nocleanup_str
    PMCPRE Debug         : $trace_str

##################################################################################
ENDOFPRINT

    # Print Design Env variables if set
    #
    showDebugParams();
}

sub displayStreamDataValuesToScreen()
{

    for my $stream (keys %streamData)
    {
        printToLogFile "\n##################################################################################";
        printToLogFile "Stream Data for $stream:";
        for my $tag (keys %{$streamData{$stream}})
        {
            my $value = ($streamData{$stream}{$tag})
                      ? $streamData{$stream}{$tag}
                      : "";  
            printToLogFile("    " . uc($tag) . ": $value");
        }  
        printToLogFile "##################################################################################\n";
    }
}

# MAIN

# First, initialize the global variables.
initGlobalVars();

my $rc = GetOptions(
        'xmlfile=s'                  => \$xmlfile, 
        'bintap-control-file=s'      => \$bintapControlFile,
        'output:s'                   => \$outdir,
        'logdir:s'                   => \$logdir,
        'patchdir:s'                 => \$patchdir,
        'update-version-file'        => \$updateVersionFile,
        'build-type=s'               => \$buildType,
        'trace'                      => \$trace,
        'generate-admindata'         => \$justAdmindata,
        'nocleanup'                  => \$nocleanup,
        'help|?'                     => \$help);

if (!$rc || defined($help))
{
   print "Unknown option: @_\n" if ( @_ );
   &showHelp;
}

print "\nUsing " . uc($tool) . " version $pkgtoolVersion.\n\n";

validateAndProcessInputVars();
printToLogFile("Validated input parameters.");

# Display the input parameters and some of the global variables to screen.
displayInputParamsToScreen();

#Admindata validation stuff
validateXmlFile($xmlfile);

#
# Parse the specified XML file.
#
my $parser = new XML::DOM::Parser;
my $doc = $parser->parsefile($xmlfile);


# Get the ADMINDATA element, and parse it
my $adminnodes = $doc->getElementsByTagName("ADMINDATA");
parseAdmindata($adminnodes->item(0));

validateAdmindata(\%admindata);

# Get the PRODUCT_COMPONENT_REQUIRES_LIST element
VpUtils::VpPatchXml::parseProductComponentRequiresListFromDoc($doc, \%nclPatchMap);
printToLogFile("nclPatchMap list: \n" . Dumper(\%nclPatchMap) . "\n", DEBUG_LEVEL_1);

# Now that we're done with the parsed XML, we can clean up the memory
$doc->dispose;

$patchid = $admindata{'PATCH_ID'};

# Now we know the patchid, append patchid to the path
$patchWorkingDir .= "/$patchid";
mkpath($patchWorkingDir) unless (-d $patchWorkingDir);

# There must be one bintap_info per stream
for my $bintap (@{$bintap_info{'bintap_info'}})
{
    printToLogFile("Bintap info value in $bintapControlFile is \'$bintap\'");

    # parse the build_info value
    # there have to be four fields defined in the following order:
    # stream, build_view, control_file, build_version
    my ($stream, $build_version, $build_view, $stream_data_xml, $build_control_file, $spec_file) = split ' ', $bintap;

    if ($stream eq "" ||
        $build_version eq "" ||
        $build_view eq "" ||
        $stream_data_xml eq "")
    {
        report_error_and_exit(BBP_RC_INVALID_PARM, "stream, build_version, build_view and stream_data xml must be defined in this order.");
    }

    report_error_and_exit(BBP_RC_FILE_NOT_EXIST, "$stream_data_xml file specified in $bintapControlFile does not exist.")
        if (!-f $stream_data_xml);

    if ($build_view ne $current_view)
    {
        # make sure the view exists
        startView($build_view);
    }

    $stream = setupStreamGlobals($stream, $build_view, $stream_data_xml);

    if ($build_control_file)
    {
        if (! -e $build_control_file)
        {
           report_error_and_exit(BBP_RC_FILE_NOT_EXIST, "The build control file, $build_control_file, does not exist.");
        }
        validateBuildControlFile($build_control_file);
        $bintap_info{'stream_info'}{$stream} = ();
        $bintap_info{'stream_info'}{$stream}{'build_view'} = $build_view;
        $bintap_info{'stream_info'}{$stream}{'build_control_file'} = $build_control_file;
        $bintap_info{'stream_info'}{$stream}{'spec_file'} = $spec_file;
    }
}

delete $bintap_info{'bintap_info'};

if (scalar keys %{$bintap_info{'stream_info'}} == 0)
{
    report_error_and_exit(BBP_RC_INVALID_PARM, "Invalid $bintapControlFile file contents. bintap_info field does not contain any build_control_file.");
}

displayStreamDataValuesToScreen();

announce "Building code sections.\n";
for my $stream (keys %{$bintap_info{'stream_info'}}) 
{
    my $build_view         = $bintap_info{'stream_info'}{$stream}{'build_view'};
    my $build_control_file = $bintap_info{'stream_info'}{$stream}{'build_control_file'};
    my $spec_file          = $bintap_info{'stream_info'}{$stream}{'spec_file'};
    
    announce "  Building code sections for $build_view view.\n\n";
    generateStreamCodeSections($stream, $build_view, $build_control_file, $spec_file);
    createStreamPackageDirs($stream);
}
print "\n";
delete $bintap_info{'stream_info'};

if (scalar keys %pkgs == 0)
{
    report_error_and_exit(BBP_RC_ERROR, "No code sections were generated.");
}

if ($justAdmindata)
{
    # We've been asked to just generate the admindata file
    my $now = `date`;
    chomp $now;

    print "Patch parcel version information:\n";
    print "#################################\n";

    for my $p (@parcels)
    {
        my $pkgname = $p->{'name'};
        my $pkgver  = $pkg_version{$pkgname};

        printf "%s:%s:%s:%s\n",
                       $pkgname,
                       $pkgver,
                       $admindata{'PATCH_ID'},
                       $now;

    }
    print "##############################################################\n\n";

    generatePatchAdmindata($tmpdir);
    `cp $tmpdir/admindata $outdir/$admindata{'PATCH_ID'}.admindata`;
    print "The admindata file has been written to: $outdir/$admindata{'PATCH_ID'}.admindata\n";
    exit BBP_RC_OK;
}


#
# Set the initial progress flags
#
for my $stream  (sort keys %pkgs)
{
    for my $pkgname (sort keys %{$pkgs{$stream}})
    {
        my $pkgver = $pkg_version{$pkgname};
        setProgressFlag($pkgname, $pkgver, FLAG_NOT_STARTED);
    }
}

for my $stream  (sort keys %pkgs)
{
    for my $pkgname (sort keys %{$pkgs{$stream}})
    {
        my $pkgver = $pkg_version{$pkgname};
        my %pkg = %{$pkgs{$stream}{$pkgname}};  

        printToLogFile("Processing $streamData{$stream}{BUILD_VIEW}.", DEBUG_LEVEL_3);
        if ($streamData{$stream}{BUILD_VIEW} eq $current_view)
        {
            runCurrentViewBuild($stream, \%pkg, $pkgname, $pkgver);
        }
        else
        {
            runOtherViewBuild($stream, \%pkg, $pkgname, $pkgver)
        }
    }
}

if (waitForThreads() > 0)
{
    report_error_and_exit(BBP_RC_ERROR, "Failed to build packages. Aborting...");
}

# Generate the admindata file
#
generatePatchAdmindata($tmpdir);

open PARCELLIST, ">$tmpdir/parcels.lst"
    or report_error_and_exit(BBP_RC_ERROR, "Failed to open $tmpdir/parcels.lst for writing");

if (scalar @parcels == 0)
{
    report_error_and_exit(BBP_RC_ERROR, "Failed to generate bintap parcels.");
}

printToLogFile("\n\nThe following parcels were built:");
for my $p (@parcels)
{
    print $bbp_logFH "$p\n";
    print PARCELLIST "$p\n";
}

close PARCELLIST;


#
# Now that the parcels have been built and the admindata generated,
# we can build the patch file.
#
print "\n\n";
announce "Building patch...";

my $cmd = "$MERGEPATCH -b -p $admindata{'PATCH_ID'} -a $tmpdir/admindata -o $outdir -f $tmpdir/parcels.lst";
open MERGE, "$cmd |" or report_error_and_exit(BBP_RC_ERROR, "Failed to launch mergepatch command.");
print while (<MERGE>);
close MERGE;
exit_if_failure("Call to $MERGEPATCH failed. Aborting...");

my $datafile = "$patchdir/$admindata{'PATCH_ID'}.data";
generatePatchDataFile($datafile, $patchWorkingDir, \%patchInfo);
print "\nThe patch data file was successfully generated. Output is:\n$datafile\n";

if ($updateVersionFile)
{

    # 1. Save the patch location to be untarred later to access the code
    # sections
    #
    # 2. update the K&R version file
    my $now = `date`;
    chomp $now;
    my $time = time();

    open VERSION, ">>$ENV{'patch_BINTAP_PATCHVER_FILE'}"
        or report_error_and_exit(BBP_RC_ERROR, "Could not update version file: $ENV{'patch_BINTAP_PATCHVER_FILE'}");

    for my $stream  (sort keys %pkgs)
    {
        for my $pkgname (sort keys %{$pkgs{$stream}})
        {
            # The bintap version file is expected to have the following format:
            # <pkgname>:<buildversion>.<num>:<tapnum>:<patchid>:<time>:extra
            printf VERSION "%s:%s:%s:%s:%s:%s\n",
                           $pkgname,
                           $pkg_version{$pkgname},
                           $bintap_version,
                           $admindata{'PATCH_ID'},
                           $time, 
                           $now;
        }
    }
    close VERSION;

}

# Patch build was successful,
# Cleanup the vsePatchCreate directory if nocleanup option is not set
if (($nocleanup) || (defined $ENV{"NOCLEANUP"}))
{
    print "\n'nocleanup' option is set, leaving the build environment as is:\n";
    print "$patchWorkingDir\n";
}
else
{
    if (-d $patchWorkingDir)
    {
        my $cmd = "find $patchWorkingDir " . '\( \! -name "*\.build_log" -type f \) -print0 | xargs -0 /bin/rm -f';
        `$cmd`;
        `rm -rf $patchWorkingDir/*/Old*  $patchWorkingDir/*/New* $patchWorkingDir/*/Info*`;
    }
}

exit BBP_RC_OK;
 
 
 
