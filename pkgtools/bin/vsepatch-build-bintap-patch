#!/usr/bin/perl
###############################################################
###############################################################

#     #                                                   ###
#  #  #    ##    #####   #    #     #    #    #   ####    ###
#  #  #   #  #   #    #  ##   #     #    ##   #  #    #   ###
#  #  #  #    #  #    #  # #  #     #    # #  #  #         #
#  #  #  ######  #####   #  # #     #    #  # #  #  ###
#  #  #  #    #  #   #   #   ##     #    #   ##  #    #   ###
 ## ##   #    #  #    #  #    #     #    #    #   ####    ###

###############################################################
#
# This file should only be updated by the USM team.
# http://wiki.us.nortel.com/twiki/bin/view/Siren/WhoIsUSM
#
# Modifications to this file affect EVERYBODY!
#
###############################################################

use strict;
use warnings 'all';
use English;
use POSIX qw(getcwd);
use Getopt::Long;
use XML::DOM;
use File::Copy;
use File::Path;
use File::Basename;
use Data::Dumper;
use Cwd qw(abs_path);

BEGIN {
    if ((defined($ENV{patch_VSE_PATCH_TOOLS_PATH})) &&
        ($ENV{patch_VSE_PATCH_TOOLS_PATH} ne ""))
    {
        if (! -d "$ENV{patch_VSE_PATCH_TOOLS_PATH}")
        {
            die "The $ENV{patch_VSE_PATCH_TOOLS_PATH} is not a directory\n\n";
        }
        unshift @INC, $ENV{'patch_VSE_PATCH_TOOLS_PATH'};
    }
    else
    {
        die "The VpUtils library path: patch_VSE_PATCH_TOOLS_PATH env variable must be defined\n\n";
    }
}

use VpUtils::VpStreamInfo;
use VpUtils::VpScptoolConfig;
use VpUtils::VpScptoolUtils;
use VpUtils::VpPatchDep;
use VpUtils::VpEbuild;
use VpUtils::VpClearcaseUtils;
use VpUtils::VpGenUtils;

# Catch interrupts to ensure the tmpdir is cleaned.
# This will result in "die" being called, which in turn will call "END".
use sigtrap qw(die normal-signals);

# Set autoflush on STDOUT
$| = 1;

# Input parms 
use vars qw (
    $xmlfile
    $ncglhaView
    $activities
    $outputDir
    $logdir
    $patchdir
    $updatedfiles
    $nocleanup
    $trace
    $buildType
    $updateVersionFile
    $buildVersion
    $loadbuild
    $ncglhaLoadbuild
    $help
);

use vars qw (
    $patchid
    $patch_key
    $pkgtoolVersion
    $current_view
    $ct
    $neu
    $ccmkview
    $buildBintapPatch
    $buildBintapSymbolRegisterCB
    $makeSyrootSymLinks
    $csfile
    $logfile
    $outdir
    $remove_views
    $date
    $tool
    %target_build_views 
    $pkgtoolBinDir
    $pkgtoolConfigDir  
    %filepaths
    %invalidPatches
    $patchWorkingDir
    $extractDir
    $controlFileDir
    $logFH
    @acts
    @ncgl_acts
    $debuglevel 
    $scptoolutils
    $streaminfo
    @requiredStreamTags
    @existingPatches
    %streamData
    $SKIP_TOOL_FILES    
);

# Determine the config dir
$pkgtoolBinDir = dirname(abs_path($0));
$pkgtoolConfigDir = (-d "$pkgtoolBinDir/config")
                  ? "$pkgtoolBinDir/config"
                  : "$pkgtoolBinDir/../config";

# Include the pkgutils.pm module
require "$pkgtoolConfigDir/pkgutils.pm";

# pkgtoolVersion must be aligned with the other pkgtools
$pkgtoolVersion = "8.0.3";

#
# showHelp:
#

#    Display the help message
#
sub showHelp
{
    print STDERR <<OUT;

Using $tool version $pkgtoolVersion

Syntax: $tool <arguments>
Where arguments are required, optional:

Required:
    --xmlfile <xmlfile>          : patch xml file.

Optional:
    --ncglha-view <arg>          : view to use for building ncglha pkgs
    --ncglha-loadbuild <arg>     : NCGL loadbuild load name only if ncgl activity included
    --activities  <arg>          : Activities that contain the changes to be patched
                                 : Must be seperated by comma.
                                 : By default, all activities in the view are selected. 
    --output <arg>               : Output directory for the patch and the patch data file.
                                   Default is \$ENV{HOME}/.vsepatch directory.
    --logdir <arg>               : Write build output to a logdir, along with
                                   progress flags. Default is /HOME/.vsepatch/logs directory.
    --build-version <arg>        : eg. 5.1.0.100801
    --loadbuild <arg>            : eg. vse51_wk09_20100307_5.1.0.100907.0 or latest_build
    --update-version-file        : Automatically update the version file
                                   upon success (should only be used by eBuild,
                                   unless using a private version file)
    --build-type <arg>           : vsepatch, ebuild or design.
                                   Default value is 'design' 
    --patchdir <arg>             : Directory to search for pre-existing patches
                                   and when build-type is design or vsepatch, 
                                   to place the patch data file after successful builds.
    --remove-views               : Removes the old and new views before creating them.
                                   By default, it uses the old and new views if they exist.
    --nocleanup                  : By default, the working directories are cleaned up after a successful build
                                   when nocleanup is set they are not cleaned up.
    --trace                      : Enable the debug logs in Code Section Creation tools (PMCPRE)  
    --help                       : Shows help

Example:
    $0 --xmlfile /vob/siren/tools/PATCHES/VSE51/<act> --loadbuild vse51_wk09_20100307_5.1.0.100907.0 --build-version 5.1.0.100907
    $0 --xmlfile /vob/siren/tools/PATCHES/VSE51/<act> \
       --loadbuild vse51_wk09_20100307_5.1.0.100907.0 \
       --build-version 5.1.0.100907 \
       --ncglha-view <ncglview> \
       --ncglha-loadbuild ncgl141oy

OUT
    exit 1;
}


sub initGlobalVars()
{

    $tool = basename($0);

    # Define global constants
    use constant VBBP_RC_OK                => 0;
    use constant VBBP_RC_INVALID_PARM      => 1;
    use constant VBBP_RC_CC_ERROR          => 2; 
    use constant VBBP_RC_DATABASE_ERROR    => 3;
    use constant VBBP_RC_FILE_NOT_EXIST    => 4;
    use constant VBBP_RC_DIR_NOT_EXIST     => 5;
    use constant VBBP_RC_PMCPRE_CTRL_ERROR => 6;
    use constant VBBP_RC_BINTAP_CTRL_ERROR => 7; 
    use constant VBBP_RC_ERROR             => 8;

    use constant DEBUG_LEVEL_0 => 0;
    use constant DEBUG_LEVEL_1 => 1;
    use constant DEBUG_LEVEL_2 => 2;
    use constant DEBUG_LEVEL_3 => 3;
    use constant DEBUG_LEVEL_4 => 4;

    use constant BUILD_TYPE_VSEPATCH => "VSEPATCH";
    use constant BUILD_TYPE_EBUILD   => "EBUILD";
    use constant BUILD_TYPE_DESIGN   => "DESIGN";


    #TODO: As an alternative to this kludgy method,
    #      pmcpcre may be changed to ignore stuff 
    #      that it doesn't understand (rather than getting really upset) 
    $SKIP_TOOL_FILES = "build|pkgtools|ntmk";
    $debuglevel = defined $ENV{DEBUG_LEVEL}
                ? $ENV{DEBUG_LEVEL}
                : DEBUG_LEVEL_0;

    # Initialize $buildType as 'DESIGN' 
    $buildType = BUILD_TYPE_DESIGN;

    # Initialize global variables
    chomp($date = `date`);
    $date =~ s/\s//g;
    $nocleanup = 0;

    #+ Ensure that /usr/atria/bin exists; if it doesn't, fail horribly.
    #+ If it does, add /usr/atria/bin to the $PATH before all else...
    my $cleartool_path = "/usr/atria/bin";
    die "$cleartool_path is required for cleartool commands: Directory does not exist.\n"
        if (!-d $cleartool_path);

    # Add it to PATH if it doesn't exist
    if ($ENV{'PATH'} !~ /:$cleartool_path/)
    {
        $ENV{'PATH'} .= ":$cleartool_path";
    }

    $ct = "/usr/atria/bin/cleartool";
    $neu = "/opt/tools/swtools/neu/6.1/bin/neu";
    $ccmkview = "/opt/corp/projects/cmtools/bin/ccmkview";

    $buildBintapPatch = "$pkgtoolBinDir/build_bintap_patch";
    $buildBintapSymbolRegisterCB = "$pkgtoolBinDir/buildBintapPatchSymbolRegister";

    $makeSyrootSymLinks = "$ENV{'patch_VSE_PATCH_TOOLS_PATH'}/make_sysroot_symlinks";

    # Initialize the required Vsepatch Utility modules
    $scptoolutils = new VpUtils::VpScptoolUtils;
    $streaminfo   = new VpUtils::VpStreamInfo;

    @requiredStreamTags = qw (
        LOADBUILD_OBJECT_DIR
        LOADBUILD_PATH
        LOAD
        FINAL_COMPILE_DIR
    );

    # I want to get all patches that are category: OBS,OBE,SUP,DBG,ABS
    VpUtils::VpPatchDep::queryIgnorePatches(\%invalidPatches);

    # Default arguments
    $buildVersion        = $ENV{'patch_FC_BUILDVERSION'};
    $loadbuild           = $ENV{'patch_FC_LOADBUILD'};
    $ncglhaLoadbuild     = $ENV{'patch_FC_NCGLHA_LOADBUILD'};

}


#
# The "END" is a special sub-routine that allows us to do some special handling
# when the script exits. This is called when either exit or die are called,
# and gives us a single place where we can clean up the temporary directory.
# This is analogous to doing a "trap on exit" in bash.
#
END
{
    my $rc = $?;

    if ($rc != 0)
    {
        print "\n";
        if ($logfile && -f $logfile) 
        {
           print "Please review the $tool logs at:\n";
           print "$logfile\n";
        }
    }
  
    close $logFH if ($logFH);
    print "$tool returns:$rc\n";
    $? = $rc;
}

########################
## Start of UTILITIES ##
########################

## announce:
##
##    This subroutine is used for displaying messages to the console with
##    a timestamp.
##
## Parameters:
##    message string
##
sub announce($)
{
    my $msg = shift;
    my @now = localtime;

    printf "%02d:%02d:%02d - %s\n",
           $now[2], $now[1], $now[0], $msg;

    if ($logFH)
    {
        printf $logFH "%02d:%02d:%02d - %s\n",
               $now[2], $now[1], $now[0], $msg;
    }
}

sub report_error_and_exit($$)
{
    my $rc = shift;
    my $msg = shift;

   VpUtils::VpGenUtils::report_error_and_exit($rc, $msg);
}

sub exit_if_failure($)
{
    my $msg = shift;
    VpUtils::VpGenUtils::exit_if_failure($msg);
}

sub printToLogFile
{
    my $msg          = shift;
    my $debug_level  = shift;

    my @now = localtime;

    $debug_level = DEBUG_LEVEL_0
        if (!$debug_level);

    if ($debuglevel >= $debug_level)
    {

        if ($logFH)
        {
            printf $logFH "%02d:%02d:%02d - %s\n",
                           $now[2], $now[1], $now[0], $msg;
        }
        else
        {
            printf "%02d:%02d:%02d - %s\n",
                    $now[2], $now[1], $now[0], $msg;
        }
    }
}

sub makePath
{
    my $path      = shift;
    my $okiferror = shift;

    eval { mkpath($path) unless (-d $path)};
    if ((!defined $okiferror) && ($@))
    {
        report_error_and_exit($@, "Failed to create $path: $@");
    }
}

sub isNcglActivity($)
{
    my $actid = shift;
    return ($actid =~ /ncgl/);
}

sub appendValueToHashField($$$)
{
    my $hash = shift;
    my $tag = shift;
    my $value = shift;

    printToLogFile("In appendValueToHashField", DEBUG_LEVEL_3);
    report_error_and_exit(VBBP_RC_INVALID_PARM, "appendValueToHashField: \'tag\' must be specified.")
        if (!$tag);

    report_error_and_exit(VBBP_RC_INVALID_PARM, "appendValueToHashField: \'value\' must be specified for $tag tag.")
        if (!$value);

    push @{$$hash{$tag}}, $value;

}

sub splitStringIgnoreComments
{
    my $str = shift;
    my $delimiter = shift;

    printToLogFile("In splitStringIgnoreComments", DEBUG_LEVEL_3);

    # Set delimiter to space if not defined
    $delimiter = (defined $delimiter)
               ? $delimiter
               : " ";

    my @array;
    my @fields = split($delimiter, $str);
    for my $field (@fields)
    {
        $field =~ s/^#.*//;  # Strip comments if line starts with "#"
        next if ($field =~ /^$/); # Skip blank lines
        push @array, $field;
    }
    return @array;
}

sub extractInfoFromFile($$)
{
    my $file  = shift;
    my $field = shift;

    report_error_and_exit(VBBP_RC_INVALID_PARM, "extractInfoFromFile: \'file to extract info from\' must be specified.")
        if (!$file);

    report_error_and_exit(VBBP_RC_FILE_NOT_EXIST, "extractInfoFromFile: $file file does not exist.")
        if (!-f $file);

    report_error_and_exit(VBBP_RC_INVALID_PARM, "extractInfoFromFile \'field\' is not specified.")
        if (! $field);

    printToLogFile("In extractInfoFromFile", DEBUG_LEVEL_3);
    my $cmd = "cat $file | grep $field";
    my @field_values = split '\n', `$cmd`;
    return @field_values;
}

########################
## End of UTILITIES ##
########################

sub cleanupOldLogsCreateNewLog($)
{
    my $logdir = shift;

    # get rid of all but the last 10 logs...
    my @keeplogs  = `sh -c "ls -rt $logdir/$tool.*.log 2>/dev/null" `;
    my $count = scalar @keeplogs;
    foreach my $log (@keeplogs)
    {
        last if ($count <= 10);
        unlink $log;
        $count--;
    }
    $logfile = "$logdir/$tool.$date.log";

    if (-e $logfile)
    {
        `rm -f $logfile 2>&1`;
    }

    # logFH handler is closed in END proc when we die or complete successfully.
    open $logFH, ">$logfile" or warn("Unable to create session log: $!");
}

sub validateAndProcessInputVars()
{
    #
    # Validate the command line parameters
    #
    report_error_and_exit(VBBP_RC_INVALID_PARM, "The patch xml file must be specified with --xmlfile.")
        if (! $xmlfile);
    
    report_error_and_exit(VBBP_RC_INVALID_PARM, "The specified file, $xmlfile, does not exist or is not readable.")
        if (! -r $xmlfile);
    
    report_error_and_exit(VBBP_RC_INVALID_PARM, "The specified logdir $logdir does not exist or is not writeable.")
        if ($logdir && ((! -d $logdir) || (! -w $logdir)));
    
    report_error_and_exit(VBBP_RC_INVALID_PARM, "The specified output dir $outdir does not exist or is not writeable.")
        if ($outdir && ((! -d $outdir) || (! -w $outdir)));

    if ($updateVersionFile)
    {
        die "The patch_BINTAP_PATCHVER_FILE environment variable must be set.\n"
            if ((!defined $ENV{'patch_BINTAP_PATCHVER_FILE'}) || ($ENV{'patch_BINTAP_PATCHVER_FILE'} eq ""));

        die "The version file ($ENV{'patch_BINTAP_PATCHVER_FILE'}) must be writeable if --update-version-file is specified.\n"
            if (! -w $ENV{'patch_BINTAP_PATCHVER_FILE'});
    }
    
    # Build type can be set via ENV{BUILD_TYPE} as well as the command line
    # Allow $ENV{BUILD_TYPE} override the buildtype option.
    $buildType = (defined $ENV{'BUILD_TYPE'})
               ? $ENV{'BUILD_TYPE'}
               : $buildType;

    $buildType = uc($buildType);

    announce "Running Build for \'$buildType\'\n";

    if (!$outdir)
    {
        $outdir = $ENV{HOME} . "/.vsepatch";
    }
    # Let's create the output directory to put the logs, code sections, etc in.
    makePath($outdir);
    
    if (!$logdir)
    {
        $logdir = "$outdir/logs";
    }
    makePath($logdir);

    cleanupOldLogsCreateNewLog($logdir);

    $patchid = VpUtils::VpEbuild::get_patch_id_from_patchXML($xmlfile);
    report_error_and_exit(VBBP_RC_INVALID_PARM, "No <PATCH_ID> is defined in $xmlfile.")
        if (!$patchid);

    if ($ncglhaView)
    {
        # Make sure the view exists
        `$ct startview $ncglhaView 2>&1`;
        exit_if_failure("Failed to activate the specified ncglha-view: $ncglhaView.");
    }
    
    # Don't delete the contents of patch working dir
    # It is shared with vsePatchCreate tool(called by build-bintap-patch),
    # which has a mechanism to enhance the build time
    # if the patch was partially/fully built once before.
    $patchWorkingDir = "$ENV{HOME}/.vsepatch/$patchid";
    makePath($patchWorkingDir);
    
    $controlFileDir = "$patchWorkingDir/control_files";
    makePath($controlFileDir);
    
    # Remove all of the control files in the output directory so that the
    # list after the creation call will be accurate.
    printToLogFile("Cleaning up control file directory: $controlFileDir", DEBUG_LEVEL_1);
    `rm -f $controlFileDir/* 2>&1`;
    
    # Find out current view
    $current_view = `$ct lsview -s -cview`;
    exit_if_failure("Failed to determine the current view");

    report_error_and_exit(VBBP_RC_ERROR, "Failed to determine current view\n")
        if (! $current_view);
    chomp($current_view);

    # Create the $extractDir if it doesn't exist already
    # Clean it up if there are anything in it.
    $extractDir = "$patchWorkingDir/previous_patches";
    makePath($extractDir);
    printToLogFile("Cleaning up extract directory: $extractDir", DEBUG_LEVEL_1);
    `rm -f $extractDir/* 2>&1`;

    if ($ENV{'BUILDBINTAP_PATCH_DIR'})
    {
        $patchdir = $ENV{'BUILDBINTAP_PATCH_DIR'};
    }
 
    # If the patchdir is not specified, we will use $outdir
    if (!$patchdir) 
    {
        $patchdir = "$outdir";
    }
    makePath($patchdir);

    # If a list of activities are specified, parse it and put it into an array.
    # The activities must be seperated by comma.
    if ($activities)
    {
        VpUtils::VpClearcaseUtils::parseAndValidateActivities($activities, \@acts, \@ncgl_acts, $ncglhaView);
    }
    else
    {
        printToLogFile("No activities are specified. Using all undelivered activities in the current view.",
                       DEBUG_LEVEL_1);
        @acts = VpUtils::VpClearcaseUtils::get_all_acts_from_view($current_view);
        exit_if_failure("Failed to retrieve activities in $current_view view.\n");
    
        if ($ncglhaView)
        {
            # Get all activities in the ncgl view
            @ncgl_acts = VpUtils::VpClearcaseUtils::get_all_acts_from_view($ncglhaView); 
            exit_if_failure("Failed to retrieve activities in $ncglhaView view.\n");
        }
    }
    
    report_error_and_exit(VBBP_RC_INVALID_PARM, "No valid clearcase activities are specified.")
        if ((scalar @acts == 0) && (scalar @ncgl_acts == 0));
    
    print "Processing the following activities:\n";
    if (scalar @acts > 0 )
    {
        print "   " . join("\n   ", @acts), "\n";
    }
    
    if (scalar @ncgl_acts > 0)
    {
        print "NCGL activities:\n";
        print "   " . join("\n   ", @ncgl_acts), "\n";
    }

}

#######################################
## Start of CLEARCASE VIEW UTILITIES ##
#######################################

sub makeView($$)
{
    my $viewname = shift;
    my $catcs = shift;

    printToLogFile("In makeView", DEBUG_LEVEL_3);
    report_error_and_exit(VBBP_RC_INVALID_PARM, "makeView: view name must be specified.")
        if (!$viewname);

    report_error_and_exit(VBBP_RC_INVALID_PARM, "makeView: config spec file must be specified for $viewname view.")
        if (!$catcs);

    # Cleanup the view if it exists 
    cleanupView($viewname);

    # If view does not exist, create view
    runCmd ($logFH,
            "make view",
            "Failed to make $viewname.\n",
            "$ccmkview -tag $viewname 2>&1");

    runCmd ($logFH,
            "start view",
            "Failed to start $viewname.\n",
            "$ct startview $viewname 2>&1");
    exit($?>>8) if ($? != 0);

    printToLogFile("Start $viewname view success",
                   DEBUG_LEVEL_1);

    runCmd($logFH,
           "Set config spec",
           "Failed to set config spec of $viewname view.\n",
           "$ct setcs -tag $viewname $catcs 2>&1");
}

sub cleanupView($)
{
    my $view = shift;

    printToLogFile("In cleanupView", DEBUG_LEVEL_3);
    report_error_and_exit(VBBP_RC_INVALID_PARM, "cleanupView: view name must be specified.")
        if (!$view);
    
    # Does the view exist? 
    `$ct startview $view 2>&1`;
    my $rc = $?;
    # If it exists 
    if ($rc == 0)
    {
        if ($remove_views)
        {
            printToLogFile("Removing $view view.", DEBUG_LEVEL_1);
            `$ct rmview -tag $view`;
        }
        else
        {
            # View exists but remove-views option is not set
            # We need to clean up the symbolic that were created previously
            cleanupSourceFiles($view); 
        }
    }
    else
    {
        printToLogFile("$view view does not exist.", DEBUG_LEVEL_1); 
    } 
}

sub cleanupSourceFiles($)
{
    my $view = shift;

    printToLogFile("In cleanupSourceFiles", DEBUG_LEVEL_3);
    `$ct startview $view 2>&1`;
    if (($? != 0) || ($remove_views))
    {
        return;
    }

    # Expected result:
    # element -file <file path> -none
    # Need 3rd field
    my @source_files;
    @source_files = `$ct catcs -tag $view |grep none | cut -f3 -d' '`;
    printToLogFile("Cleaning up the following source files in $view view.\n    " .
                   join("    ", @source_files));
    for my $file ( @source_files)
    {
        chomp($file);
        $file = "/view/$view$file";
        if (-f $file)
        {
            system("rm -f $file 2>/dev/null");
            exit_if_failure("Cannot delete $file file");
        }
    }
}

#######################################
## End of CLEARCASE VIEW UTILITIES ##
#######################################


###########################################################
# Start of PREPARE TARGET VIEW FOR PATCH BUILD PROCEDURES #
###########################################################

# USES THE FOLLOWING GLOBAL VARIABLES:
#     @ncgl_acts;
#     $ncglhaView
#     $streaminfo
#     $current_view
#     @acts
#
# UPDATES THE FOLLOWING GLOBAL VARIBLES:
#     target_build_views
#
sub prepareTargetBuildViews()
{
    printToLogFile("In prepareTargetBuildViews", DEBUG_LEVEL_3);
    if (scalar @ncgl_acts > 0)
    {
        announce "Retrieving source files for $ncglhaView view.";
        my @ncgl_source_files = checkSourceFiles($ncglhaView, \@ncgl_acts);
        if (scalar @ncgl_source_files > 0)
        {
            printToLogFile("Appending $ncglhaView view to the target builds.");
            if ($ENV{BUILDBINTAP_NCGL_STREAM_DATA_XML})
            {
                $target_build_views{$ncglhaView}{'stream_data_xml'} = $ENV{BUILDBINTAP_NCGL_STREAM_DATA_XML};
            }
            appendViewToTargetBuildViews($ncglhaView, \@ncgl_source_files, \%target_build_views);
        }
        else
        {
            report_error_and_exit(VBBP_RC_ERROR, "No patchable files found to be associated in $ncglhaView view.");
        }
    }
    else
    {
        printToLogFile("No ncgl activites are specified.");
    }
    
    # Add current view to the target views
    # get streamid from view name
    # We need to add the current view even though there is no source file
    # associated with it.
    # The current view doesn't have to have any activities or 
    # updated files on it when building
    # bundled patches. 
    # For instance, ncgl patches are built from a vse view
    # Both @acts and @ncgl_acts having size 0 is validated 
    # at the validateAndProcessInputVars.
    my @source_files;
    if (scalar @acts > 0)
    {
        announce "Retrieving source files for $current_view view";
        @source_files = checkSourceFiles($current_view, \@acts);
        if (scalar @source_files == 0)
        {
            # Only acceptable if there are ncgl activities specified.
            # In this case, the current view is used as home to the pkgtools.
            if (scalar @ncgl_acts > 0)
            {
                print "\nINFO: No source files in $current_view view.\n\n";
                printToLogFile("INFO: No source files in $current_view view.");
            }
            else
            {
                report_error_and_exit(VBBP_RC_ERROR, "No patchable files are found in the $current_view view.");
            }
        }
    }

    # Add current view to the target views 
    # even if no source files in the current view. 
    # This scenario happens when building bundled patches(NCGL patches on a VSE view).
    printToLogFile("Appending $current_view view to the target builds.");
    if ($ENV{BUILDBINTAP_STREAM_DATA_XML})
    {
        $target_build_views{$current_view}{'stream_data_xml'} = $ENV{BUILDBINTAP_STREAM_DATA_XML};
    }
    appendViewToTargetBuildViews($current_view, \@source_files, \%target_build_views); 
   
}

# USES THE FOLLOWING GLOBAL VARIABLES:
#     $patchid
#     $patchWorkingDir
sub appendViewToTargetBuildViews($$$)
{
    my $view                   = shift;
    my $source_files           = shift;
    my $target_build_views_ref = shift;

    report_error_and_exit(VBBP_RC_INVALID_PARM, "appendViewToTargetBuildViews: \'view\' must be specified.\n")
        if (!$view);
    printToLogFile("In appendViewToTargetBuildViews", DEBUG_LEVEL_3);

    # get streamid from view name
    my $stream_id = $streaminfo->get_stream_id_from_cc_view($view);
    report_error_and_exit(VBBP_RC_CC_ERROR, "appendViewToTargetBuildViews: Failed to retrieve stream id from $view view")
        if (!$stream_id);

    if (!exists($target_build_views_ref->{$view}))
    {
        $target_build_views_ref->{$view} = ();
    }
    $target_build_views_ref->{$view}{'streamid'} = $stream_id;
    $target_build_views_ref->{$view}{'oldview'} = "$ENV{USER}_$stream_id-$patchid" . "_old";
    $target_build_views_ref->{$view}{'newview'} = "$ENV{USER}_$stream_id-$patchid" . "_new";
    $target_build_views_ref->{$view}{'source_files'} = $source_files;
    my $patchWorkingStreamDir = "$patchWorkingDir/$stream_id";
    makePath($patchWorkingStreamDir);
    $target_build_views_ref->{$view}{'control_file'} = "$patchWorkingStreamDir/$patchid:$stream_id.control";

    # This env variable is added for 
    # + Supporting streams that are not defined in PACS
    # + Support patch builds on private loads vs. loadbuild loads 
    if (!$target_build_views_ref->{$view}{'stream_data_xml'})
    {
        $target_build_views_ref->{$view}{'stream_data_xml'} = "$controlFileDir/$stream_id" . "_data.xml";
    }

    # The patch data spec file is going to be filled at two points:
    # 1. If a new variable or constant or procedure is introduced with this patch, 
    #    the callback script($buildBintapSymbolRegisterCB) will add 
    #    + new_dyn_constant
    #    + new_dyn_variable
    #    + new_dyn_procedure
    #    values to the stream specific 'spec_file'.
    #
    # 2. All the rest of the fields like: pot_prereq_prod, shadow_patch_prod
    #    fields wil be added by $buildBintapPatch tool after a successful patch
    #    build. 
    $target_build_views_ref->{$view}{'spec_file'} = "$patchWorkingStreamDir/$patchid:$stream_id.spec";
}

sub checkSourceFiles($$)
{
    my $view    = shift;
    my $act_ref = shift;

    printToLogFile("In checkSourceFiles", DEBUG_LEVEL_3);
    my @act_array = @{$act_ref};
    my @updated_files;

    my @updated_patch_files;

    report_error_and_exit(VBBP_RC_INVALID_PARM, "checkSourceFiles: view name must be specified.\n")
        if (!$view);
    
    report_error_and_exit(VBBP_RC_INVALID_PARM, "checkSourceFiles: No activity specified.\n")
        if (scalar @act_array == 0);

    chomp(@act_array);
    chomp (my $myacts = join(" ", @act_array));
    printToLogFile("Checking source files for these activities:\n $myacts\n");

    my $tmp = basename($xmlfile);
    my $cmd = "$ct lsact -l $myacts | grep @@ | cut -f1 -d@ | sort | uniq | grep -v $tmp";
    if ($view eq $current_view)
    {
        @updated_files = `$cmd`;
    }
    else
    {
        @updated_files = `cd / && $ct setview -exec \"$cmd\" $view`;
    }
    
    for my $file (@updated_files)
    {
        chomp($file);
        $file =~ s/^\s+//;
        $file =~ s/\s+$//;

        # We cannot patch the build and pkg tools 
        next if ($file =~ /\/$SKIP_TOOL_FILES\//i);
        next if (-d $file);
        push @updated_patch_files, $file;
    }

    printToLogFile("Updated patch files: \n" . join("\n", @updated_patch_files) . "\n")
        if (scalar @updated_patch_files > 0);
    return @updated_patch_files;
}

###########################################################
# End of PREPARE TARGET VIEW FOR PATCH BUILD PROCEDURES #
###########################################################


#########################
#
# CREATE CONTROL FILES
#
#########################

sub validateStreamDataFields($$$)
{
    my $streamid        = shift;
    my $stream_data_xml = shift;
    my $stream_data     = shift;

    my $target;

    report_error_and_exit(VBBP_RC_INVALID_PARM, "validateStreamDataFields: stream id must be specified.\n")
        if (!$streamid);

    printToLogFile("In validateStreamDataFields", DEBUG_LEVEL_3);
    printToLogFile("Validating $streamid stream data");

    # This env variable is added for
    # + Supporting streams that are not defined in PACS
    # + Support patch builds on private loads vs. loadbuild loads
    if (!$ENV{BUILDBINTAP_STREAM_DATA_XML})
    {
        # Download Stream data xml file from PACS
        $scptoolutils->stream_data_xml_retrieve($streamid, $stream_data_xml);
        exit_if_failure("Failed to download stream data xml file from PACS.");
    }

    report_error_and_exit(VBBP_RC_FILE_NOT_EXIST, "$stream_data_xml file does not exist.")
        if (! -f $stream_data_xml);

    updateStreamXmlFileIfReq($streamid, $stream_data_xml);

    $target = $streaminfo->parseStreamXmlFile($stream_data_xml, $streamid, $stream_data);

    my @missingVars;
    for my $streamTag (@requiredStreamTags)
    {
        if (!$stream_data->{$target}{$streamTag})
        {
            push (@missingVars, $streamTag);
        }
    }

    if (scalar @missingVars != 0)
    {
        print STDERR "The following required stream info has not been datafilled:\n";
        for my $v (@missingVars)
        {
            print STDERR "\t$v\n";
        }
        exit(VBBP_RC_INVALID_PARM);
    }
}

# Updates the following fields in the stream data xml file if required:
#     LOADBUILD_PATH
#     PACKAGE_VERSION
#     LOADBUILD_RPM_VERSION_FILE
#     LOADBUILD_BINTAP_VERSION_FILE
#     LOADBUILD_INCREMENT_DIR
#     LOADBUILD_OBJECT_DIR
#     FINAL_COMPILE_DIR
#     LOAD
sub updateStreamXmlFileIfReq($$)
{
    my $stream_id         = shift;
    my $stream_data_xml   = shift;
    my $replace_all = 1;

    printToLogFile("In updateStreamXmlFileIfReq", DEBUG_LEVEL_3);
    # Do not allow changing load and buildversion information for EBUILD builds.
    if ($buildType eq BUILD_TYPE_DESIGN)
    {
        my $isNcglStream = $streaminfo->is_NCGL_stream($stream_id);
        if ((!$isNcglStream) && ($loadbuild))
        {
            # If loadbuild is specified, update the following values in the xml:
            #      LOADBUILD_PATH
            #      LOAD
            #      FINAL_COMPILE_DIR
            #
            printToLogFile("$loadbuild is specified as loadbuild, updating stream data..");
            replaceStreamTagsInXml($stream_data_xml, 'FINAL_COMPILE_DIR', $loadbuild, $replace_all);
        }
        
        if (($isNcglStream) && ($ncglhaLoadbuild))
        {
            # If loadbuild is specified, update the following values in the xml:
            #      LOADBUILD_PATH
            #      LOAD
            #      FINAL_COMPILE_DIR
            #
            printToLogFile("$ncglhaLoadbuild is specified as ncglha-loadbuild, updating stream data.");
            replaceStreamTagsInXml($stream_data_xml, 'FINAL_COMPILE_DIR', $ncglhaLoadbuild, $replace_all);
        }
  
        if ($buildVersion)
        {
            printToLogFile("$buildVersion is specified as build-version, updating stream data.");
            replaceStreamTagsInXml($stream_data_xml, 'PACKAGE_VERSION', $buildVersion);
        }

        if (($ENV{LOADBUILD_INCREMENT_DIR}) && (!$isNcglStream))
        {
            if (!-e $ENV{LOADBUILD_INCREMENT_DIR} )
            {
                report_error_and_exit(VBBP_RC_DIR_NOT_EXIST,
                    "The specified LOADBUILD_INCREMENT_DIR \'$ENV{LOADBUILD_INCREMENT_DIR}\' does not exist.");
            }
            printToLogFile("$ENV{LOADBUILD_INCREMENT_DIR} is specified as LOADBUILD_INCREMENT_DIR, updating stream data.");
            replaceStreamTagsInXml($stream_data_xml, 'LOADBUILD_INCREMENT_DIR', $ENV{LOADBUILD_INCREMENT_DIR});
        }

        if (($ENV{NCGLLOADBUILD_INCREMENT_DIR}) && ($isNcglStream))
        {
            if (!-e $ENV{NCGLLOADBUILD_INCREMENT_DIR} )
            {
                report_error_and_exit(VBBP_RC_DIR_NOT_EXIST,
                    "The specified NCGLLOADBUILD_INCREMENT_DIR \'$ENV{NCGLLOADBUILD_INCREMENT_DIR}\' does not exist.");
            }
            printToLogFile("$ENV{NCGLLOADBUILD_INCREMENT_DIR} is specified as LOADBUILD_INCREMENT_DIR, updating stream data.");
            replaceStreamTagsInXml($stream_data_xml, 'LOADBUILD_INCREMENT_DIR', $ENV{NCGLLOADBUILD_INCREMENT_DIR});
        }
    }

    # EBUILD passes the version file information to us via these env vars.    
    if ($ENV{patch_RPM_PATCHVER_FILE})
    {
        if (! -r $ENV{patch_RPM_PATCHVER_FILE})
        {
            report_error_and_exit(VBBP_RC_FILE_NOT_EXIST, 
              "The specified patch_RPM_PATCHVER_FILE verson file \'$ENV{patch_RPM_PATCHVER_FILE}\' does not exist or is not readable.");
        }

        printToLogFile("$ENV{patch_RPM_PATCHVER_FILE} is specified as patch_RPM_PATCHVER_FILE, updating stream data.");
        replaceStreamTagsInXml($stream_data_xml, 'LOADBUILD_RPM_VERSION_FILE', $ENV{patch_RPM_PATCHVER_FILE});
    }

    if ($ENV{patch_BINTAP_PATCHVER_FILE})
    {
        if (! -r $ENV{patch_BINTAP_PATCHVER_FILE})
        {
            report_error_and_exit(VBBP_RC_FILE_NOT_EXIST,
              "The specified patch_BINTAP_PATCHVER_FILE version file \'$ENV{patch_BINTAP_PATCHVER_FILE}\' does not exist or is not readable.");
        }
        printToLogFile("$ENV{patch_BINTAP_PATCHVER_FILE} is specified as patch_BINTAP_PATCHVER_FILE, updating stream data.");
        replaceStreamTagsInXml($stream_data_xml, 'LOADBUILD_BINTAP_VERSION_FILE', $ENV{patch_BINTAP_PATCHVER_FILE});
   }   
}

sub replaceStreamTagsInXml
{
    my $stream_data_xml = shift;
    my $tag = shift;
    my $new_value = shift;
    my $change_all = shift;

    printToLogFile("In replaceStreamTagsInXml", DEBUG_LEVEL_3);
    my $all = ($change_all)
            ? "g"
            : " ";

    $tag = uc($tag);
    chomp(my $current_value = `grep -Po '<$tag>.*</$tag>' $stream_data_xml | sed 's/<\\/*$tag>//g'`);

    # No action required if the current and the new values are same.
    if ($current_value)
    {
        if ($current_value eq $new_value)
        {
            printToLogFile("No action required, the current value of \'$tag\' is already $current_value.");
            return;
        }
    }
    printToLogFile("Replacing $current_value \'$tag\' values with $new_value");

    # If the current_value is null,
    # Use the tags as the replacement keywords. 
    if (!$current_value)
    {
        $current_value = "<$tag></$tag>";
        $new_value = "<$tag>$new_value</$tag>";
    }    

    # Replace / with \/ to pass the real / value.
    $current_value =~ s/\//\\\//g; 
    $new_value     =~ s/\//\\\//g; 
    runCmd ($logFH,
            "Replace $tag",
            "Failed to replace $current_value \'$tag\' value $new_value.",
            "sed -i 's/$current_value/$new_value/$all' $stream_data_xml");
    exit($?>>8) if ($? != 0);
}

##################################################
# Start of CREATE PMCPRE CONTROL FILE PROCEDURES #
##################################################

sub addLoadFieldsToPmcpreControlData($$$)
{
    my $stream_id   = shift;
    my $stream_data = shift;
    my $controldata = shift;

    printToLogFile("In addLoadFieldsToPmcpreControlData", DEBUG_LEVEL_3);
    # The stream_data fields are validated prior to this proc
    # No validation required here.

    # If LOADBUILD_INCREMENT_DIR exists(designer option), we will map:
    #    LOADBUILD_PATH           ==> formal_build_dir
    #    LOADBUILD_INCREMENT_DIR  ==> load_dir
    #    LOAD                     ==> load
    #
    # Else (Production default)
    #    LOADBUILD_PATH           ==> load_dir
    #    LOAD                     ==> load
    #
    if ($stream_data->{'LOADBUILD_INCREMENT_DIR'})
    {
        appendValueToHashField($controldata, 'formal_build_dir', $stream_data->{'LOADBUILD_PATH'});
        appendValueToHashField($controldata, 'load_dir', $stream_data->{'LOADBUILD_INCREMENT_DIR'});
        appendValueToHashField($controldata, 'load', $stream_data->{'LOAD'});
    }
    else
    {
        # Each bintap have to build on top of the latest released RPM patch.
        # getLatestRpmPatchBuildPath determines the latest released VALID
        # (non-OBS, non-DBG, non-SUP, etc category patch)
        # If it cannot find anything, returns the milestone(LOADBUILD_PATH) loaddir.
        # For DESIGN builds, we use the loadbuild_path by default
        # For Bintap on K&R scenario for DESIGN builds, user have to specify
        # the LOADBUILD_INCREMENT_DIR as the K&R build environment.
        my $load_dir;
        if ($buildType eq BUILD_TYPE_DESIGN)
        {
            $load_dir = $stream_data->{'LOADBUILD_PATH'};
        }
        else
        {
            $load_dir = VpUtils::VpPatchDep::getLatestRpmPatchBuildPath($stream_id, \%invalidPatches);
            if ($load_dir ne $stream_data->{'LOADBUILD_PATH'})
            {
                appendValueToHashField($controldata, 'formal_build_dir', $stream_data->{'LOADBUILD_PATH'});
            }
        }
        appendValueToHashField($controldata, 'load_dir', $load_dir);
        appendValueToHashField($controldata, 'load', $stream_data->{'LOAD'});
    }

    appendValueToHashField($controldata, 'object_dir', $stream_data->{'LOADBUILD_OBJECT_DIR'});

}

sub addSymbolRegFieldsToPmcpreControlData($$)
{
    my $target_build_views_ref  = shift;
    my $controldata = shift;

    printToLogFile("In addSymbolRegFieldsToPmcpreControlData", DEBUG_LEVEL_3);
    my $spec_file = $target_build_views_ref->{'spec_file'};

    if (-f $spec_file)
    {
        `rm -f $spec_file 2>&1`;
        exit_if_failure("Failed to remove $spec_file file while adding SymbolRegFields");
    }

    # When the patch is being built, 
    # the buildBintapSymbolRegisterCB is executed by PMCPRE tool to register
    # the new symbols.
    appendValueToHashField($controldata, 
                           'new_dyn_constant_reg', 
                           "$buildBintapSymbolRegisterCB $spec_file new_dyn_constant");
    appendValueToHashField($controldata,
                           'new_dyn_variable_reg',
                           "$buildBintapSymbolRegisterCB $spec_file new_dyn_variable");
    appendValueToHashField($controldata, 
                           'new_dyn_procedure_reg',
                           "$buildBintapSymbolRegisterCB $spec_file new_dyn_procedure");
}

sub addProductArchToPmcpreControlData($$)
{
    my $stream_data  = shift;
    my $controldata = shift;

    printToLogFile("In addProductArchToPmcpreControlData", DEBUG_LEVEL_3);
    # The stream_data fields are validated prior to this proc
    # No validation required here.

    my @product_archs;

    if ($stream_data->{'LOADBUILD_INCREMENT_DIR'})
    {
        # If LOADBUILD_INCREMENT_DIR is set, 
        # determine product_archs from load_pifs.
        # The supported architectures might be different in this load.
        # Ideally, it shouldn't.
        @product_archs = determineProductArch($stream_data->{'LOADBUILD_INCREMENT_DIR'});
    }
    elsif ((-z $stream_data->{'ARCHITECTURES_BINTAP'}) && ($ENV{'ADD_PRODUCT_ARCH'}))
    {
        # If ADD_PRODUCT_ARCH is set, user requested the product_archs to be
        # re-calculated.
        @product_archs = determineProductArch($stream_data->{'LOADBUILD_PATH'});
    }
    elsif ($stream_data->{'ARCHITECTURES_BINTAP'})
    {
        @product_archs = splitStringIgnoreComments($stream_data->{'ARCHITECTURES_BINTAP'});
        if (scalar @product_archs == 0 && $ENV{'ADD_PRODUCT_ARCH'})
        {
            # If ADD_PRODUCT_ARCH is set, user requested the product_archs to be
            # re-calculated.
            @product_archs = determineProductArch($stream_data->{'LOADBUILD_PATH'});
        }
    }
    elsif (-z $stream_data->{'ARCHITECTURES_BINTAP'} && -z $ENV{'ADD_PRODUCT_ARCH'})
    {
        report_error_and_exit(VBBP_RC_PMCPRE_CTRL_ERROR, "ARCHITECTURES_BINTAP field has not been datafilled.");
    }
    else
    {
        # This scenario should never happen.
        print "Unknown combination of loadbuild fields.\n";
        if ($stream_data->{'LOADBUILD_INCREMENT_DIR'})
        {
            print "LOADBUILD_INCREMENT_DIR: $stream_data->{'LOADBUILD_INCREMENT_DIR'}\n";
        }
        if ($stream_data->{'ARCHITECTURES_BINTAP'})
        {
            print "ARCHITECTURES_BINTAP: $stream_data->{'ARCHITECTURES_BINTAP'}\n";
        }
        if ($ENV{'ADD_PRODUCT_ARCH'})
        {
            print "ADD_PRODUCT_ARCH: $ENV{'ADD_PRODUCT_ARCH'}\n";
        }

    }

    # The product_archs must be filled by now
    # Fail if it is still empty.
    if (scalar @product_archs == 0)
    {
        report_error_and_exit(VBBP_RC_PMCPRE_CTRL_ERROR, "Failed to add product architectures to PMCPRE control data.");
    }

    $controldata->{'product_arch'} = \@product_archs;
}

# Find all load_pif files in the specified load directory
# The load_pif files is expected to be in the following format:
#     <product_arch>.load_pif
# Add product_arch to the @product_archs. 
sub determineProductArch($)
{
    my $load_dir = shift;
    my @product_archs;

    report_error_and_exit(VBBP_RC_INVALID_PARM, "determineProductArch: load_dir must be specified.\n")
        if (!$load_dir);

    report_error_and_exit(VBBP_RC_DIR_NOT_EXIST, "determineProductArch: $load_dir does not exist.\n")
        if (!-e $load_dir);
    printToLogFile("In determineProductArch", DEBUG_LEVEL_3);

    my $command = "ls $load_dir/*/pkgs/*.load_pif";
    if (!open(LS, "$command |"))
    {
        report_error_and_exit(VBBP_RC_ERROR, "determineProductArch: \'$command\' command failed. $!\n");
    }

    while (<LS>)
    {
        my $pif_file = $ARG;
        # Remove spaces at the beginning and end of the pif_file
        $pif_file =~ s/^\s+//;
        $pif_file =~ s/\s+$//;

        my $basename = basename($pif_file);
        if ($basename =~ /^(.*)\.load_pif$/)
        {
           printToLogFile("Adding $1 to product_arch field");
           push(@product_archs, $1);
        }
        else
        {
            report_error_and_exit(VBBP_RC_ERROR, "determineProductArch: Unknown load_pif name format\n");
        }
    }

    if (!close(LS))
    {
        report_error_and_exit(VBBP_RC_ERROR, "determineProductArch: Failed to close \'$command\' output. $!\n");
    }

    if ($CHILD_ERROR != 0)
    {
        report_error_and_exit(VBBP_RC_ERROR, "determineProductArch: \'$command\' failed. rc = $CHILD_ERROR\n");
    }

    return @product_archs;
}

sub addViewsToPmcpreControlData($$)
{
    my $target_view_ref = shift;
    my $controldata = shift;

    printToLogFile("In addViewsToPmcpreControlData", DEBUG_LEVEL_3);
    appendValueToHashField($controldata, 'old_view', $target_view_ref->{'oldview'});
    appendValueToHashField($controldata, 'new_view', $target_view_ref->{'newview'});
}

sub addUpdateFilesToPmcpreControlData($$)
{
    my $target_view_ref = shift;
    my $controldata = shift;

    printToLogFile("In addUpdateFilesToPmcpreControlData", DEBUG_LEVEL_3);
    report_error_and_exit(VBBP_RC_PMCPRE_CTRL_ERROR, "No source file specified.\n")
        if (!$target_view_ref->{'source_files'});

    $controldata->{'update_file'} = $target_view_ref->{'source_files'};
}


sub addPotPrereqToPmcpreControlData($$$)
{
    my $patch_spec_file = shift;
    my $controldata     = shift;
    my $csDir           = shift;

    printToLogFile("In addPotPrereqToPmcpreControlData", DEBUG_LEVEL_3);
    my @pot_prereq_prods = extractInfoFromFile($patch_spec_file, 'pot_prereq_prod');
    if (scalar @pot_prereq_prods > 0)
    {
        printToLogFile("Adding potential prereq patches to control data.", DEBUG_LEVEL_1);
        for my $pot_prereq_prod (@pot_prereq_prods)
        {
            # Strip the pot_prereq_prod part as we will be adding it later
            # when writing to control file.
            $pot_prereq_prod =~ s/^pot_prereq_prod //;

            # We must add the full paths of previous code sections.
            # When the data files are being created, the REPLACE_WITH_DIR
            # placeholder is added for the code section dirs to be added when they are
            # extracted.
            # We have the code sections extracted to the $csDir from the .data file,
            # so replace them.
            $pot_prereq_prod =~ s/REPLACE_WITH_DIR/$csDir/;
            printToLogFile("  Appending $pot_prereq_prod to control data.", DEBUG_LEVEL_1);
            appendValueToHashField($controldata, 'pot_prereq_prod', $pot_prereq_prod);
        }
    }

    my @shadow_patch_prods = extractInfoFromFile($patch_spec_file, 'shadow_patch_prod');
    if (scalar @shadow_patch_prods > 0)
    {
        for my $shadow_patch_prod (@shadow_patch_prods)
        {
            # Strip the shadow_patch_prod part since we will be adding it later
            # when writing to control file.
            $shadow_patch_prod =~ s/^shadow_patch_prod //;

            # We must add the full paths of previous shadow files.
            # When the data files are being created, the REPLACE_WITH_DIR
            # placeholder is added as the shadow file dirs to be added when they are
            # extracted.
            # We have the shadow files extracted from .data file to the $csDir, 
            # so replace them.
            $shadow_patch_prod =~ s/REPLACE_WITH_DIR/$csDir/;
            printToLogFile("  Appending $shadow_patch_prod to control data.", DEBUG_LEVEL_1);
            appendValueToHashField($controldata, 'shadow_patch_prod', $shadow_patch_prod);
        }
    }
}

# If a patch adds a new constant or a new variable or a new procedure,
# new_dyn_constant or new_dyn_variable or new_dyn_procedure fields are added
# to the Patch specification file of the patch by the
# buildBintapPatchSymbolRegister Call Back script which is called by PMCPRE.
# These values are then used to create patches that depend on these patches.
# We have to loop through each of the existingPatches and add these fields to 
# the PMCPRE control file. 
sub addNewDynSymToPmcpreControlData($$)
{
    my $patch_spec_file = shift;
    my $controldata     = shift;

    printToLogFile("In addNewDynSymToPmcpreControlData", DEBUG_LEVEL_3);
    # Add new dynamic constants if there are any
    my @new_dyn_constants = extractInfoFromFile($patch_spec_file, 'new_dyn_constant');
    if (scalar @new_dyn_constants > 0)
    {
        for my $new_dyn_constant (@new_dyn_constants)
        {
            $new_dyn_constant =~ s/^new_dyn_constant //;
            printToLogFile("  Appending $new_dyn_constant to control data.", DEBUG_LEVEL_1);
            appendValueToHashField($controldata, 'new_dyn_constant', $new_dyn_constant);
        }
    }

    # Add new dynamic variables if there are any
    my @new_dyn_variables = extractInfoFromFile($patch_spec_file, 'new_dyn_variable');
    if (scalar @new_dyn_variables > 0)
    {
        for my $new_dyn_variable (@new_dyn_variables)
        {
            $new_dyn_variable =~ s/^new_dyn_variable //;
            printToLogFile("  Appending $new_dyn_variable to control data.", DEBUG_LEVEL_1);
            appendValueToHashField($controldata, 'new_dyn_variable', $new_dyn_variable);
        }
    }

    # Add new dynamic procedures if there are any
    my @new_dyn_procedures = extractInfoFromFile($patch_spec_file, 'new_dyn_procedure');
    if (scalar @new_dyn_procedures > 0)
    {
        for my $new_dyn_procedure (@new_dyn_procedures)
        {
            $new_dyn_procedure =~ s/^new_dyn_procedure //;
            printToLogFile("  Appending $new_dyn_procedure to control data.", DEBUG_LEVEL_1);
            appendValueToHashField($controldata, 'new_dyn_procedure', $new_dyn_procedure);
        }
    }
}

# USES THE FOLLOWING GLOBAL VARIABLES:
#     @existingPatches;
#     $extractDir;
sub addDepFieldsToPmcpreControlData($$)
{
    my $streamid = shift;
    my $controldata = shift;

    printToLogFile("In addDepFieldsToPmcpreControlData", DEBUG_LEVEL_3);
    printToLogFile("Input parameters. " .
                   "Stream: $streamid, " .
                   "ExtractDir: $extractDir, " .
                   "Patches: @existingPatches", DEBUG_LEVEL_2);
    # Fail if there are existing bintap patches and the extractdir is null.
    # The patch data files have to be extracted and the extract dir has to be
    # defined up to this point.
    if ((scalar @existingPatches > 0) && !$extractDir)
    {
        report_error_and_exit(VBBP_RC_PMCPRE_CTRL_ERROR, "Patch extract dir is NULL");
    }

    # We have to consider all previous bintap patches as potential
    # prerequisite patches.
    # Depending on their contents, vsePatchCreate tool determines the correct
    # list of required patches.
    # ExistingPatches are added to the array ordered by the creation date.
    for my $patchid (@existingPatches)
    {
        my $csDir = "$extractDir/$patchid/$streamid";
        printToLogFile("Processing $patchid in $csDir");
        # If the $patchid has $streamid component. The patch doesn't
        # necessarily have packages built for this stream.
        if (-d $csDir)
        {
            # Each patch data file contents are extracted to $patchid dirs under $extractDir
            # The code sections, patch_info and shadow_files, spec file and
            # control files are placed into $stream sub directories.
            # The expected spec filename format is:
            #   $patchid:$streamid.spec
            printToLogFile("Adding $patchid as potential prereq patch.");
            my $patch_spec_file = "$csDir/$patchid:$streamid.spec";
            addPotPrereqToPmcpreControlData($patch_spec_file, $controldata, $csDir);
            addNewDynSymToPmcpreControlData($patch_spec_file, $controldata);
        }
    }
}


sub extractExistingBintapDataFiles($$$)
{
    my $releaseid      = shift;
    my $extractdir     = shift;
    my $downloaddir    = shift;

    my (@patches, $patch);

    printToLogFile("In extractExistingBintapDataFiles", DEBUG_LEVEL_3);

    # For designer builds, in addition to downloading the patches from PACS
    # Also use the .data files in the specified $patchdir.
    # Assuming all prevous patches are in PACS and the $patchdir 
    if ($buildType eq BUILD_TYPE_DESIGN)
    {
        @patches = downloadPreviousPatchDataFiles($releaseid, $downloaddir);

        # The "ls -lrt" command will give us the patches in the order they are created.
        # To help ordering the hash later in this order,
        # assign increasing values to the hash.
        # We have to return this as hash structure not array because the main code
        # which determines the existing patches by reading the version file returns hash
        # for accessing easily.
        # The main code assigns the actual dates as the value.
        printToLogFile("Searching for patch data files in $patchdir", DEBUG_LEVEL_1);
        my @patchlist = `ls -lrt $patchdir/*.data  2>/dev/null |awk '{print \$NF}'`;
        for $patch (@patchlist)
        {
            $patch = `basename $patch`;
            $patch =~ s/\.data//;
            chomp($patch);
            # Just skipping this patch as this is a designer build
            next if ($patch eq $patchid);
            `ln -sf $patchdir/$patch.data $downloaddir/$patch.data`;
            exit_if_failure("Failed to create $downloaddir/$patch.data softlink to $patchdir/$patch.data");
            push @patches, $patch;
        }
    }
    else
    {
        @patches = downloadPreviousPatchDataFiles($releaseid, $downloaddir);
    }

    if (scalar @patches > 0)
    {
        printToLogFile("Previously built/released patches are: \n   " . join("\n   ", @patches));
        announce "Extracting existing bintap patch data files";
    }
    else
    {
        printToLogFile("No previously built/released patches were found.");
    }

    # Extract the data files
    for $patch (@patches)
    {
        # In theory, this should never occur.
        # Just being extra cautious.
        report_error_and_exit(VBBP_RC_ERROR, "The existing patchid is same as the patchid we are building.")
            if ($patch eq $patchid);
        
        my $datafile = "$downloaddir/$patch.data";
        report_error_and_exit(VBBP_RC_FILE_NOT_EXIST, "extractExistingBintapDataFiles: $datafile does not exist.\n")
            if (!-f $datafile);
  
        my $patchExtractDir = "$extractDir/$patch";
        makePath($patchExtractDir);
        printToLogFile("Cleaning up patch extract directory: $patchExtractDir", DEBUG_LEVEL_1);
        `rm -f $patchExtractDir/* 2>&1`;

        announce "    Extracting $patch.data to $patchExtractDir";
        my $cmd = "tar xf $datafile -C $patchExtractDir";
        system("$cmd 2>&1");
        exit_if_failure("Failed to extract $datafile to $patchExtractDir dir. Cmd: $cmd\n");
    }
    return @patches;
}

sub downloadPreviousPatchDataFiles($$)
{
    my $releaseid     = shift;
    my $downloaddir   = shift;

    my (@patches, $patch);
    
    printToLogFile("In downloadPreviousPatchDataFiles", DEBUG_LEVEL_3);

    # Get all VALID(non-OBS, non-SUP, non-DBG) previous patches from
    # PACS
    @patches = VpUtils::VpPatchDep::getPreBintapPatchesFromPatchData($releaseid, \%invalidPatches);
    
    if (scalar @patches == 0)
    {
        printToLogFile("No previously released patches found in PACS.");
    }

    # Download the data files of each patch from PACS to $downloaddir if ebuild
    #
    for $patch (@patches)
    {
        printToLogFile("Downloading $patch data file from PACS.", DEBUG_LEVEL_1);
        $scptoolutils->patch_data_file_retrieve($patch, "$downloaddir/$patch.data");
    }

    return @patches;
}

sub generatePmcpreControlFile($$$)
{
    my $controldata = shift;
    my $patchid     = shift;
    my $control_file = shift;

    printToLogFile("In generatePmcpreControlFile", DEBUG_LEVEL_3);
    # First add the default values to the controldata
    appendValueToHashField($controldata, 'patch_status', "open");
    appendValueToHashField($controldata, 'tool_version', "current");
    appendValueToHashField($controldata, 'patch_id', $patchid);

    `rm $control_file 2>&1`;
    
    if (!open(BUILD_CONTROL, "> $control_file"))
    {
        report_error_and_exit(VBBP_RC_ERROR, "Failed to open $control_file for writing. $!\n");
    }

    printToLogFile("Control data: \n" . Dumper($controldata), DEBUG_LEVEL_3);
    for my $control_line (keys %{$controldata})
    {
        for my $line (@{$controldata->{$control_line}})
        {
            print BUILD_CONTROL "$control_line $line\n";
        }
    }

    close(BUILD_CONTROL);

    # Validate the file is actually created.
    report_error_and_exit(VBBP_RC_FILE_NOT_EXIST, "Failed to create $control_file.")
        if (!-f $control_file);

}

sub createPmcpreControlFile($$$)
{
    my $patchid        = shift;
    my $view            = shift;
    my $target_view_ref = shift;

    my %controlData_l;

    printToLogFile("In createPmcpreControlFile", DEBUG_LEVEL_3);
    my $target_stream = $target_view_ref->{'streamid'};

    addLoadFieldsToPmcpreControlData($target_stream, \%{$streamData{$target_stream}}, \%controlData_l);
    addSymbolRegFieldsToPmcpreControlData($target_view_ref, \%controlData_l);
    addProductArchToPmcpreControlData(\%{$streamData{$target_stream}}, \%controlData_l);
    addViewsToPmcpreControlData($target_view_ref, \%controlData_l);
    addUpdateFilesToPmcpreControlData($target_view_ref, \%controlData_l);
    addDepFieldsToPmcpreControlData($target_view_ref->{'streamid'}, \%controlData_l);
    generatePmcpreControlFile(\%controlData_l, $patchid, $target_view_ref->{'control_file'});

}

################################################
# End of CREATE PMCPRE CONTROL FILE PROCEDURES #
################################################

##################################################
# Start of CREATE BINTAP CONTROL FILE PROCEDURES #
##################################################
sub createBintapControlFile($)
{
    my $bintap_file = shift;
    my %controlData_l;

    printToLogFile("In createBintapControlFile", DEBUG_LEVEL_3);
    appendValueToHashField(\%controlData_l, 'bintap_version', $patch_key);
    for my $view (keys %target_build_views)
    {
        my $stream = $target_build_views{$view}{'streamid'};
        my $stream_data_xml = $target_build_views{$view}{'stream_data_xml'};

        # For some cases(eg: when building NCGL patches),
        # It is OK not to have any soruce files in the current view.
        # If the there are no source files in the view, 
        # we don't need a control file or a spec file.
        # Because we won't be building patches on that stream.
        my $bintap_info;
        if (scalar @{$target_build_views{$view}{'source_files'}} == 0)
        {
            $bintap_info = "$stream $streamData{$stream}{PACKAGE_VERSION} $view $stream_data_xml";
        }
        else
        {  
            my $control_file = $target_build_views{$view}{'control_file'};
            my $spec_file = $target_build_views{$view}{'spec_file'};
            $bintap_info = "$stream $streamData{$stream}{PACKAGE_VERSION} $view $stream_data_xml $control_file $spec_file";
        }
        appendValueToHashField(\%controlData_l, 'bintap_info', $bintap_info);
    }
    generateBintapControlFile(\%controlData_l, $bintap_file);

}

sub generateBintapControlFile($$)
{
    my $controldata = shift;
    my $control_file = shift;

    printToLogFile("In generateBintapControlFile", DEBUG_LEVEL_3);
    `rm $control_file 2>&1`;

    if (!open(CONTROL, "> $control_file"))
    {
        report_error_and_exit(VBBP_RC_ERROR, "Failed to open $control_file for writing. $!");
    }

    printToLogFile("Control data: \n" . Dumper($controldata), DEBUG_LEVEL_3);
    for my $control_line (keys %{$controldata})
    {
        for my $line (@{$controldata->{$control_line}})
        {
            print CONTROL "$control_line $line\n";
        }
    }

    close(CONTROL);

    # Validate the file is actually created.
    report_error_and_exit(VBBP_RC_FILE_NOT_EXIST, "Failed to create $control_file.")
        if (!-f $control_file);
}

################################################
# End of CREATE BINTAP CONTROL FILE PROCEDURES #
################################################


############################################################
# Start of OLD/NEW VIEW CONFIG SPEC CALCULATION PROCEDURES #
############################################################

# Creates the system root links
sub createSysrootSymlinks($$$)
{
    my $streamid = shift;
    my $target_view_ref = shift;
    my $stream_data = shift;
      
    my $load = $stream_data->{FINAL_COMPILE_DIR};

    my $new_view = $target_view_ref->{'newview'};
    my $old_view = $target_view_ref->{'oldview'};

    my $setupCmd = $stream_data->{BUILD_SETUP};
    # Create the symlinks on the old view
    printToLogFile("Creating symlinks for $old_view, setup Cmd: $setupCmd");
    runCmdInView(
            $old_view,
            $logFH,
            "Create symlinks",
            "Failed to create symlinks in $old_view.\n",
            "$setupCmd && $makeSyrootSymLinks -load_ver $load");
    exit($?>>8) if ($? != 0);
 
    # Create the symlinks on the new view
    printToLogFile("Creating symlinks for $old_view");
    runCmdInView(
            $new_view,
            $logFH,
            "Create symlinks",
            "Failed to create symlinks in $new_view.\n",
            "$setupCmd && $makeSyrootSymLinks -load_ver $load");
    exit($?>>8) if ($? != 0);
}

sub prepareStreamForBuildPatch($$)
{
    my $myview = shift;
    my $target_view_ref = shift;
    
    printToLogFile("In prepareStreamForBuildPatch", DEBUG_LEVEL_3);
    printToLogFile("prepareStreamForBuildPatch: Target view: \n" . Dumper(\%{$target_view_ref}),
                   DEBUG_LEVEL_3);

    if ($buildType eq BUILD_TYPE_EBUILD)
    {
        prepareStreamForBuildPatchEbuild($myview, $target_view_ref);
    }
    elsif ($buildType eq BUILD_TYPE_VSEPATCH)
    {
        prepareStreamForBuildPatchVsepatch($myview, $target_view_ref);
    }
    elsif ($buildType eq BUILD_TYPE_DESIGN)
    {
        prepareStreamForBuildPatchTest($myview, $target_view_ref);
    }
    else
    {
        report_error_and_exit(VBBP_RC_INVALID_PARM, "Unknown build type: $buildType.\n");
    }
}

##########
# EBUILD #
##########
sub prepareStreamForBuildPatchEbuild($$)
{
    my $myview = shift;
    my $target_view_ref = shift;

    printToLogFile("In prepareStreamForBuildPatchEbuild", DEBUG_LEVEL_3);
    my $updated_files = $target_view_ref->{'source_files'};

    # Do the rest only if the view contains source files
    if (scalar @{$updated_files} > 0)
    {    
        my $mystreamid = $target_view_ref->{'streamid'};
        my $new_view = $target_view_ref->{'newview'};
        my $old_view = $target_view_ref->{'oldview'};

        announce "Preparing $mystreamid stream for building bintap patch.";

        announce "    Creating $old_view view.";
        createOldViewEbuild($old_view, $myview, $mystreamid);
        
        announce "    Creating $new_view view.";
        createNewViewEbuild($new_view, $myview);
    }
}

sub createOldViewEbuild($$$)
{
    my $old_view   = shift;
    my $myview   = shift;
    my $streamid = shift;
    my ($baseline, $catcs);

    report_error_and_exit(VBBP_RC_INVALID_PARM, "createOldViewEbuild: Old view must be defined.\n")
        if (!$old_view);

    report_error_and_exit(VBBP_RC_INVALID_PARM, "createOldViewEbuild: current view must be defined.\n")
        if (!$myview);
    printToLogFile("In createOldViewEbuild", DEBUG_LEVEL_3);

    # Get latest patch
    $baseline = VpUtils::VpPatchDep::getLatestBintapPatchBaseline($streamid, \%invalidPatches);
    printToLogFile("The latest patch baseline is $baseline.");
    $catcs = "$controlFileDir/$old_view.configspec";
    
    # Get config spec of the baseline
    getBaselineConfigSpec($myview, $baseline, $catcs);

    makeView($old_view, $catcs);
}

sub createNewViewEbuild($$)
{
    my $new_view     = shift;
    my $myview       = shift;
    my ($baseline, $catcs);

    report_error_and_exit(VBBP_RC_INVALID_PARM, "createNewViewEbuild: New view must be specified.\n")
        if (!$new_view);

    report_error_and_exit(VBBP_RC_INVALID_PARM, "createNewViewEbuild: current view must be specified.\n")
        if (!$myview);

    printToLogFile("In createNewViewEbuild", DEBUG_LEVEL_3);
    # Get current view baseline
    $baseline = VpUtils::VpEbuild::get_latest_baseline_in_view($myview);
    printToLogFile("The latest baseline in $myview view: $baseline.");

    $catcs = "$controlFileDir/$new_view.configspec";

    # Get config spec of the baseline
    getBaselineConfigSpec($myview, $baseline, $catcs);

    makeView($new_view, $catcs);
}

sub getBaselineConfigSpec($$$)
{
    my $view      = shift;
    my $baseline  = shift;
    my $csfile    = shift;

    printToLogFile("In getBaselineConfigSpec", DEBUG_LEVEL_3);
    my $cmd;
    if ($view eq $current_view)
    {
        # Get config spec of this baseline
        $cmd = "$neu mkroview -cs baseline:$baseline | grep -v '\#'";
        runCmd ($logFH,
                "Get config spec for baseline",
                "Failed to get config spec for $baseline baseline.\n",
                "$cmd 1>$csfile");
        exit($?>>8) if ($? != 0);
    }
    else
    {
        # Get config spec of this baseline
        $cmd = "cd / && $ct setview -exec \"$neu mkroview -cs baseline:$baseline | grep -v '\#'\" $view";
        runCmd ($logFH,
                "Get config spec for baseline",
                "Failed to get config spec for $baseline baseline.\n",
                "$cmd 1>$csfile");
        exit($?>>8) if ($? != 0);
    }
}


sub getConfigSpecFromStream($$)
{
    my $view      = shift;
    my $csfile    = shift;

    printToLogFile("In getConfigSpecFromStream", DEBUG_LEVEL_3);
    my $cmd;
    my $streamname;
        
    # Get stream name in stream_name@project_vob format
    # Strip off the "stream:" at the beginning
    chomp($streamname = `$ct lsstream -fmt '%Xn' -view $view |cut -d: -f2`);
    announce "    Getting config spec for $streamname stream.";
    # Get config spec of this baseline
    $cmd = "$neu mkroview -cs $streamname | grep -v '\#'";
    runCmd ($logFH,
            "Get config spec for $streamname",
            "Failed to get config spec for $streamname stream.\n",
            "$cmd 1>$csfile");
    exit($?>>8) if ($? != 0);
}

######################################
# VSEPATCH (When called by VSEPATCH) #
######################################
sub prepareStreamForBuildPatchVsepatch($$)
{
    my $myview = shift;
    my $target_view_ref = shift;

    printToLogFile("In prepareStreamForBuildPatchVsepatch", DEBUG_LEVEL_3);
    my $updated_files = $target_view_ref->{'source_files'};

    # Do the rest only if the view contains source files
    if (scalar @{$updated_files} > 0)
    {
        my $mystreamid = $target_view_ref->{'streamid'};
        my $new_view = $target_view_ref->{'newview'};
        my $old_view = $target_view_ref->{'oldview'};

        announce "Preparing $mystreamid stream for building bintap patch.";

        announce "    Creating $old_view view.";
        createOldViewVsepatch($old_view, $myview, $mystreamid);

        announce "    Creating $new_view view.";
        createNewViewVsepatch($new_view, $updated_files, $myview);
    }
}

sub createOldViewVsepatch($$$)
{
    my $old_view = shift;
    my $myview   = shift;
    my $streamid = shift;
    printToLogFile("In createOldViewVsepatch", DEBUG_LEVEL_3);
    createOldViewEbuild($old_view, $myview, $streamid);
}

sub createNewViewVsepatch($$$)
{
    my $new_view     = shift;
    my $source_files = shift;
    my $myview       = shift;
    my ($baseline, $catcs);

    printToLogFile("In createNewViewVsepatch", DEBUG_LEVEL_3);
    # Get current view baseline
    $baseline = VpUtils::VpEbuild::get_latest_baseline_in_view($myview);
    printToLogFile("The latest baseline in $myview view: $baseline.");

    $catcs = "$controlFileDir/$new_view.configspec";

    # Get config spec of the baseline
    getBaselineConfigSpec($myview, $baseline, $catcs);

    # Add the source files to the config spec
    appendSourceFilesToConfigSpec($source_files, $catcs);

    makeView($new_view, $catcs);

    copySourceFilesFromToView($source_files, $myview, $new_view);
}

sub appendSourceFilesToConfigSpec($$)
{
    my $source_files = shift;
    my $csfile = shift;

    printToLogFile("In appendSourceFilesToConfigSpec", DEBUG_LEVEL_3);
    if (scalar @{$source_files} == 0)
    {
        return;
    }

    report_error_and_exit(VBBP_RC_ERROR, "Failed to read $csfile file, it either does not exist or not readable")
        if (! -f $csfile);

    # Need to append the source files to the beginning of the config spec
    # So save the config spec in an array
    # We will append this after we add the source files.
    if (!open(CONFIG_SPEC, $csfile))
    {
        report_error_and_exit(VBBP_RC_ERROR, "\nFailed to open $csfile for reading. $!");
    }

    my @config_spec_lines = <CONFIG_SPEC>;
    close(CONFIG_SPEC);

    if (!open(CONFIG_SPEC, " > $csfile"))
    {
        report_error_and_exit(VBBP_RC_ERROR, "\nFailed to open $csfile for writing. $!");
    }

    # First add the source files
    for my $source_file (@{$source_files})
    {
        print CONFIG_SPEC "element -file $source_file -none\n";
    }

    for my $line (@config_spec_lines)
    {
        print CONFIG_SPEC $line;
    }

    if (!close(CONFIG_SPEC))
    {
        report_error_and_exit(VBBP_RC_ERROR, "Failed to close $csfile file. $!");
    }
}

sub copySourceFilesFromToView($$$)
{
    my $updated_files = shift;
    my $from_view = shift;
    my $to_view = shift;
    my $cmd;

    report_error_and_exit(VBBP_RC_INVALID_PARM, "copySourceFilesFromToView: \'from_view\' must be specified.")
        if (!$from_view);

    report_error_and_exit(VBBP_RC_INVALID_PARM, "copySourceFilesFromToView: \'to_view\' must be specified.")
        if (!$to_view);

    printToLogFile("In copySourceFilesFromToView", DEBUG_LEVEL_3);
    # Copy each source file from the current view to the new view
    # spec that links each file in the activity to /view/<pwv>/<file-in-activity>
    for my $file (@{$updated_files})
    {
        chomp($file);
        $file =~ s/^\s+//;
        $file =~ s/\s+$//;
        # Filter directories and files from tools directories: Not patchable
        next if ($file =~ /\/$SKIP_TOOL_FILES\//i);
        next if (-d $file);

        $cmd = "cd / && $ct setview -exec \"rm -f $file\" $to_view 2>&1";
        `$cmd`;
        if ($? != 0)
        {
            printToLogFile("Cannot delete $file in $to_view.", DEBUG_LEVEL_1);
        }

        printToLogFile("Copying $file from $from_view view to $to_view.");
        $cmd = "cp /view/$from_view$file /view/$to_view$file";
        system("$cmd");
        exit_if_failure("Failed to run \'$cmd\' command.\n");

        # Verify the file was copied succesfully
        report_error_and_exit(VBBP_RC_FILE_NOT_EXIST, "Failed to copy $file file to $to_view view.\n")
            if (! -f "/view/$to_view$file");
    }
}

###########################################
# DESIGNER (When called with DESIGN option) #
###########################################
sub prepareStreamForBuildPatchTest($$)
{
    my $myview = shift;
    my $target_view_ref = shift;

    printToLogFile("In prepareStreamForBuildPatchTest", DEBUG_LEVEL_3);
    announce "Preparing $target_view_ref->{'streamid'} stream for building bintap patch.";

    createOldAndNewViewTest($myview, $target_view_ref);
}


# A lot of things we do are same for old and new views.
# It is better to handle them in the same proc.
sub createOldAndNewViewTest($$)
{
    my $view            = shift;
    my $target_view_ref = shift;
    my ($baseline, $myview_catcs, $old_catcs, $new_catcs, %patched_file_path_map);

    printToLogFile("In createOldAndNewViewTest", DEBUG_LEVEL_3);
    my $updated_files = $target_view_ref->{'source_files'};

    my $streamid = $target_view_ref->{'streamid'};
    my $new_view = $target_view_ref->{'newview'};
    my $old_view = $target_view_ref->{'oldview'};

    # For designers, to give some freedom.
    # Creating old and new views based on:
    # 1) Default:  the baseline of the current view.
    # 2) Optional: the config spec of the development stream 
    #    which includes the checked in files.
    if (defined $ENV{BINTAP_DEV})
    {
        $myview_catcs = "$controlFileDir/$view.configspec";
        getConfigSpecFromStream($view, $myview_catcs);
    }
    else
    {
        # Get current view baseline
        announce "    Getting latest baseline in $view view.";
        $baseline = VpUtils::VpEbuild::get_latest_baseline_in_view($view);
        printToLogFile("The latest baseline in $view view: $baseline.");

        $myview_catcs = "$controlFileDir/$baseline.configspec";

        # Get config spec of the baseline
        announce "    Getting config spec for $baseline baseline.";
        getBaselineConfigSpec($view, $baseline, $myview_catcs);
    }

    announce "    Creating $old_view view.";
    $old_catcs = "$controlFileDir/$old_view.configspec";
    copy("$myview_catcs", "$old_catcs")
        or report_error_and_exit(VBBP_RC_ERROR, "Failed to copy from $myview_catcs to $old_catcs.");

    # Get patched source files from control files of previous patches 
    %patched_file_path_map = getPatchedSourceFiles($streamid);
    my @source_files = keys %patched_file_path_map;
    appendSourceFilesToConfigSpec(\@source_files, $old_catcs);

    # Make old view
    makeView($old_view, $old_catcs);

    copyPatchedSourceFilesToView(\%patched_file_path_map, $old_view);

    announce "    Creating $new_view view.";
    $new_catcs = "$controlFileDir/$new_view.configspec";
    copy("$old_catcs", "$new_catcs")
        or report_error_and_exit(VBBP_RC_ERROR, "Failed to copy from $old_catcs to $new_catcs.");

    # Up to now, we added the old config spec content to the new view
    # Now, we will add the updated files in this patch.
    appendSourceFilesToConfigSpec($updated_files, $new_catcs);
    
    # Make new view
    makeView($new_view, $new_catcs);

    copyPatchedSourceFilesToView(\%patched_file_path_map, $new_view);
    copySourceFilesFromToView($updated_files, $view, $new_view);

}

# USES THE FOLLOWING GLOBAL VARIABLES:
#     $patchdir
#     $extractDir
#     %existingPatches
#
sub getPatchedSourceFiles($)
{
    my $streamid = shift;

    printToLogFile("In getPatchedSourceFiles", DEBUG_LEVEL_3);
    my (%updated_file_path_map, @update_files);

    # This should never happen, though just to be cautious.
    # For DESIGN build, we store the actual update files in the .data file.
    # This is done to prepare the old and new views with the correct config
    # specs for patch on patch case.
    # This is not an issue for VSEPATCH and EBUILD builds because the source
    # codes will already be included in the baselines.
    if ($buildType ne BUILD_TYPE_DESIGN)
    {
        report_error_and_exit(VBBP_RC_ERROR, "getPatchedSourceFiles is only supported for build-type: DESIGN\n");
    }

    # The previous patch data files should be extracted by now
    if (scalar @existingPatches == 0)
    {
        return;
    }

    for my $patch (@existingPatches)
    {
        my $temp_patch_dir = "$extractDir/$patch";
        my $stream_dir = "$temp_patch_dir/$streamid";
        
        # $patch doesn't necessarily have $streamid component.
        # Skip this patch if no $streamid component
        if (!-d $stream_dir)
        {
            next;
        }
        my $control_file = "$stream_dir/$patch:$streamid.control";
        
        my @update_files = extractInfoFromFile($control_file, 'update_file');
        report_error_and_exit(VBBP_RC_ERROR, "$control_file must contain \'update_file\' field.\n")
            if (scalar @update_files == 0);

        for my $file (@update_files)
        {
            # $file will be extracted from the control file in the following format:
            # "update_file /vob/siren/sw_mgmt/usmcommon/base/src/USMHwMtcUtil.c"
            # So we need to remove the update_file part to get the file
            $file =~ s/^update_file //; 
            my $file_path = "$temp_patch_dir/" . basename($file);

            # The production patches don't have update_file in their .data files
            # This is OK since that code is already in the current view baseline.
            next if (!-f $file_path);

            printToLogFile("$file was updated in $patch patch.Full path: $file_path", DEBUG_LEVEL_1);
            # If this file was patched in earlier patches, 
            # assuming that the newer patch will include the changes from
            # earlier patches, always use the latest version of the file.
            # So, override the previous $updated_file_path_map{$file} value.
            $updated_file_path_map{$file} = $file_path;
        }
    }
    printToLogFile("Patched file path map: \n" . Dumper(\%updated_file_path_map), DEBUG_LEVEL_2);
    return %updated_file_path_map;
}


sub copyPatchedSourceFilesToView($$)
{
    my $patched_files_ref = shift;
    my $to_view = shift;
    my $cmd;

    printToLogFile("In copyPatchedSourceFilesToView", DEBUG_LEVEL_3);

    # Copy each source file from the current view to the new view
    # spec that links each file in the activity to /view/<pwv>/<file-in-activity>
    for my $file (keys %{$patched_files_ref})
    {
        chomp($file);
        $file =~ s/^\s+//;
        $file =~ s/\s+$//;
        # Filter directories and files from tools directories: Not patchable
        next if ($file =~ /\/$SKIP_TOOL_FILES\//i);
        next if (-d $file);

        $cmd = "cd / && $ct setview -exec \"rm $file\" $to_view 2>&1";
        `$cmd`;
        if ($? != 0)
        {
            printToLogFile("Cannot delete $file in $to_view view.", DEBUG_LEVEL_1);
        }

        printToLogFile("Copying $patched_files_ref->{$file} to $to_view view.", DEBUG_LEVEL_1);
        $cmd = "cd / && $ct setview -exec \"cp $patched_files_ref->{$file} $file\" $to_view";
        system("$cmd");
        exit_if_failure("Failed to run $cmd command.\n");

        # Verify the file was copied succesfully
        if (! -f "/view/$to_view$file")
        {
            report_error_and_exit(VBBP_RC_ERROR, "Failed to copy $file file.");
        }
    }
}

##########################################################
# End of OLD/NEW VIEW CONFIG SPEC CALCULATION PROCEDURES #
##########################################################


sub showDebugParams()
{
    if (defined $ENV{patch_RPM_PATCHVER_FILE} ||
        defined $ENV{patch_BINTAP_PATCHVER_FILE} ||
        defined $ENV{NO_IGNORE_PATCHES} ||
        defined $ENV{ADD_PRODUCT_ARCH} ||
        defined $ENV{LOADBUILD_INCREMENT_DIR} ||
        defined $ENV{NCGLLOADBUILD_INCREMENT_DIR} ||
        defined $ENV{LOAD} ||
        defined $ENV{DEBUG_LEVEL} ||
        defined $ENV{BUILD_TYPE} ||
        defined $ENV{NOCLEANUP} ||
        defined $ENV{BINTAP_DEV})
    {
        print "########################################\n";
        print "User Defined Environment variables:\n";
        print "########################################\n";
        print "    patch_RPM_PATCHVER_FILE     : $ENV{patch_RPM_PATCHVER_FILE}\n"
            if (defined $ENV{patch_RPM_PATCHVER_FILE});
        print "    patch_BINTAP_PATCHVER_FILE  : $ENV{patch_BINTAP_PATCHVER_FILE}\n"
            if (defined $ENV{patch_BINTAP_PATCHVER_FILE});
        print "    ADD_PRODUCT_ARCH            : $ENV{ADD_PRODUCT_ARCH}\n"
            if (defined $ENV{ADD_PRODUCT_ARCH});
        print "    LOADBUILD_INCREMENT_DIR     : $ENV{LOADBUILD_INCREMENT_DIR}\n"
            if (defined $ENV{LOADBUILD_INCREMENT_DIR});
        print "    NCGLLOADBUILD_INCREMENT_DIR : $ENV{NCGLLOADBUILD_INCREMENT_DIR}\n"
            if (defined $ENV{NCGLLOADBUILD_INCREMENT_DIR});
        print "    LOAD                        : $ENV{LOAD}\n"
            if (defined $ENV{LOAD});
        print "    DEBUG_LEVEL                 : $ENV{DEBUG_LEVEL}\n"
            if (defined $ENV{DEBUG_LEVEL});
        print "    BUILD_TYPE                  : $ENV{BUILD_TYPE}\n"
            if (defined $ENV{BUILD_TYPE});
        print "    NOCLEANUP                   : $ENV{NOCLEANUP}\n"
            if (defined $ENV{NOCLEANUP});
        print "    Using Development Stream data\n"
            if (defined $ENV{BINTAP_DEV});
        print "#########################################\n\n";
    }
}

sub displayInputParamsToScreen()
{

    my $update_version_file_str = ($updateVersionFile)
                                ? "On"
                                : "Off";
 
    my $nocleanup_str = ($nocleanup)
                      ? "On"
                      : "Off";
 
    my $trace_str = ($trace)
                  ? "On"
                  : "Off";

    print <<ENDOFPRINT;
##################################################################################
    Patch ID             : $patchid
    Patch XML file       : $xmlfile
    Update Version File  : $update_version_file_str
    Build Type           : $buildType
    Output Dir           : $outdir
    Log Dir              : $logdir
    Patch Dir            : $patchdir
    Nocleanup            : $nocleanup_str
    PMCPRE Debug         : $trace_str
##################################################################################
ENDOFPRINT

    showDebugParams();
}

# MAIN #
########

# First initialize the global variables
initGlobalVars();

my $rc = GetOptions(
        'xmlfile=s'                  => \$xmlfile,
        'ncglha-view=s'              => \$ncglhaView,
        'activities=s'               => \$activities,
        'build-version=s'            => \$buildVersion,
        'loadbuild=s'                => \$loadbuild,
        'ncglha-loadbuild=s'         => \$ncglhaLoadbuild,
        'update-version-file'        => \$updateVersionFile,
        'build-type=s'               => \$buildType,
        'output=s'                   => \$outdir,
        'logdir=s'                   => \$logdir,        
        'patchdir=s'                 => \$patchdir,        
        'remove-views'               => \$remove_views,  
        'nocleanup'                  => \$nocleanup,
        'trace'                      => \$trace,
        'help|?'                     => \$help);

if (!$rc || defined($help))
{
   print "Unknown option: @_\n" if ( @_ );
   &showHelp;
}

print "\nUsing " . uc($tool) . " version $pkgtoolVersion.\n\n";

validateAndProcessInputVars();

printToLogFile("Validated input parameters.");

# Display the input parameters and some of the global variables to screen.
displayInputParamsToScreen();

# Always register the patch as TEST,
# For production, vsepatch will have it registered as PRODUCTION
# Trying to registering a patch that has already been registered as PRODUCTION
# will NOT re-register, it will return the registered KEY.
$patch_key = $scptoolutils->patch_key_register($patchid, "TEST");
report_error_and_exit(VBBP_RC_INVALID_PARM, "Null patch key returned from database.")
    if (!$patch_key);
printToLogFile("Key \'$patchid\' has been registered in the database with a unique-id of \'$patch_key\'");

my $releaseid = $streaminfo->get_release_id_from_cc_view($current_view);
report_error_and_exit(VBBP_RC_INVALID_PARM, "Null release_id returned from database.")
    if (!$releaseid);

# Add source files and all kinds of view related information
# to the target_build_views hash
prepareTargetBuildViews();

printToLogFile("prepareTargetBuildViews completed: \n" . Dumper(\%target_build_views),
               DEBUG_LEVEL_3);

# First, extract the existing patches..
@existingPatches = extractExistingBintapDataFiles($releaseid,
                                                  $extractDir,
                                                  $patchWorkingDir);
for my $view (keys %target_build_views)
{
    my $stream = $target_build_views{$view}{'streamid'};
    # First validate the required stream data fields
    # It parses downloads the stream dta from pacs
    validateStreamDataFields($stream, $target_build_views{$view}{'stream_data_xml'}, \%streamData);

    if (scalar @{$target_build_views{$view}{'source_files'}} == 0)
    {
        # We allow the current view to not contain any source files
        # Because we use the current view as a host for the pkgtools
        # If none of the views contain any source files,
        # we die at earlier point in prepareTargetBuildViews.
        next;
    }

    announce "Creating PMCPRE control file for $stream stream."; 
    createPmcpreControlFile($patchid, $view, $target_build_views{$view});

    prepareStreamForBuildPatch($view, 
                               $target_build_views{$view});

    # Create the NCGL_SYSTEM_ROOT symlinks on both old and new views
    createSysrootSymlinks($stream, $target_build_views{$view}, $streamData{$stream});
}

announce "Creating Bintap control file.";
my $bintap_control_file = "$controlFileDir/$patchid.bintap";
createBintapControlFile($bintap_control_file);

printToLogFile("Bintap Control file is generated: $bintap_control_file");

announce "Building $patchid patch...";
my $build_opts;
$build_opts  = " --logdir $logdir"        if ($logdir);
$build_opts .= " --output $outdir"        if ($outdir);
$build_opts .= " --patchdir $patchdir"    if ($patchdir);
$build_opts .= " --nocleanup"             if ($nocleanup);
$build_opts .= " --trace"                 if ($trace);
$build_opts .= " --update-version-file"   if ($updateVersionFile);
$build_opts .= " --build-type $buildType" if ($buildType);
runCmdOnScreen ($logFH,
                "buildBintapPatch",
                "Failed to build $patchid bintap patch.\n",
                "$buildBintapPatch --xmlfile $xmlfile --bintap-control-file $bintap_control_file $build_opts");
exit($?>>8) if ($? != 0);

print "$patchid is built successfully.\n";  

# Patch build was successful, 
# Cleanup the control files directory if nocleanup option is not set
if (($nocleanup) || (defined $ENV{"NOCLEANUP"}))
{
    print "\n'nocleanup' option is set, leaving the build environment as is:\n";
    print "$patchWorkingDir\n";
}
else
{
    # Do not delete the $patchWorkingDir directly
    # because it is shared by $buildBintapPatch tool and the code section
    # creation logs are placed under this folder.
    # buildBintapPatch tool cleans up that folder without deleting the logs.
    `rm -rf $controlFileDir`
        if (-d $controlFileDir);

    `rm -rf $extractDir`
        if (-d $extractDir);

}

exit(0);


